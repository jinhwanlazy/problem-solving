snippet clsedge "basic edge struct"
struct Edge
{
	int u;
	int v;
	${1:int} w; /* cost */

	friend bool operator< (const Edge& lhs, const Edge& rhs) {
		return lhs.w > rhs.w;
	}
};
endsnippet

snippet algdijkstra "Dijkstra's shortest path algorithm"
class Dijkstra {
 public:
	using cost_t = int;
	static constexpr cost_t INF = numeric_limits<cost_t>::max();

	struct State {
		int u;
		cost_t cost;

		friend bool operator<(const State& lhs, const State& rhs) { return lhs.cost > rhs.cost; }
	};

	struct Edge {
		int u;
		int v;
		cost_t cost;
	};

 public:
	const vector<vector<Edge>>& graph_;
	vector<cost_t> costs_;
	vector<int> trace_;

	int src_;
	int dst_ = -1;
	bool doTrace_ = false;

 public:
	Dijkstra(const vector<vector<Edge>>& adjListGraph, int src)
			: graph_(adjListGraph), costs_(adjListGraph.size()), trace_(0), src_(src) {}

	void setDoTrace() { doTrace_ = true; }
	void setSrc(int src) { src_ = src; }
	void setDst(int dst) { dst_ = dst; }
	const vector<cost_t>& cost() const { return costs_; }
	const vector<int>& trace() const { return trace_; }

	void solve() {
		if (src_ == -1) {
			throw runtime_error("src is not defined!");
		}
		fill(costs_.begin(), costs_.end(), INF);
		if (doTrace_) {
			trace_.resize(costs_.size());
			fill(trace_.begin(), trace_.end(), -1);
		}

		priority_queue<State> pq;
		costs_[src_] = 0;
		pq.push({src_, 0});
		while (!pq.empty()) {
			auto [u, c] = pq.top();
			pq.pop();
			if (costs_[u] < c) {
				continue;
			}
			if (u == dst_) {
				break;
			}
			for (const auto& [_, v, w] : graph_[u]) {
				cost_t nextCost = c + w;
				if (nextCost < costs_[v]) {
					costs_[v] = nextCost;
					pq.push({v, nextCost});
					if (doTrace_) {
						trace_[v] = u;
					}
				}
			}
		}
	}
};
endsnippet

snippet algbellman "Bellman-Ford, shortest path algorithm."
struct Edge {
	int u;
	int v;
	LL cost;
};

bool bellmanFord(const vector<Edge>& edges, int nVertices, int src, vector<LL>& cost) {
	cost.resize(nVertices);
	fill(cost.begin(), cost.end(), INF);
	cost[src] = true;

	for (int i = 0; i < nVertices; ++i) {
		for (const auto& [u, v, c] : edges) {
			if (cost[u] != INF && cost[v] > cost[u] + c) {
				cost[v] = cost[u] + c;
				if (i == nVertices-1) {
					return false;
				}
			}
		}
	}
	return true;
}
endsnippet


snippet algfloyd "Floyd-Warshall, shortest path algorithm"
class FloydWarshall {
 public:
	using T = int;

	const vector<vector<T>>& graph_;
	vector<vector<T>> costs_;
	FloydWarshall(const vector<vector<T>>& graph) : graph_(graph), costs_(0) {}

	void solve() {
		size_t N = graph_.size();
		costs_ = graph_;

		for (int k = 0; k < N; ++k) {
			for (int i = 0; i < N; ++i) {
				for (int j = 0; j < N; ++j) {
					if (costs_[i][k] != INF && costs_[k][j] != INF) {
						costs_[i][j] = min(costs_[i][k] + costs_[k][j], costs_[i][j]);
					}
				}
			}
		}
	}

	const vector<vector<T>>& cost() const {
		return costs_;
	}
};
endsnippet

snippet algunionfind "Union Find Set data structure"
struct UnionFindSet {
	UnionFindSet(int size) : root_(size), rank_(size, 0), size_(size, 1) {
		for (int i = 0; i < size; ++i) {
			root_[i] = i;
		}
	}

	int find(int i) {
		if (root_[i] == i) {
			return i;
		}
		int root = find(root_[i]);
		root_[i] = root;
		return root;
	}

	int merge(int i, int j) {
		int i_root = find(i);
		int j_root = find(j);
		if (i_root == j_root) {
			return size_[i_root];
		}
		if (rank_[i_root] < rank_[j_root]) {
			root_[i_root] = j_root;
			size_[j_root] += size_[i_root];
			size_[i_root] = 0;
			return size_[j_root];
		}
		root_[j_root] = i_root;
		size_[i_root] += size_[j_root];
		size_[j_root] = 0;
		if (rank_[i_root] == rank_[j_root]) {
			rank_[i_root]++;
		}
		return size_[i_root];
	}

	bool resize(size_t size) {
		size_t size_before = root_.size();

		if (size_before >= size) {
			return false;
		}
		root_.resize(size);
		rank_.resize(size, 0);
		size_.resize(size, 1);
		for (size_t i = size_before; i < size; ++i) {
			root_[i] = i;
		}
		return true;
	}

	size_t size() const {
		return root_.size();
	}

	vector<int> root_;
	vector<int> rank_;
	vector<int> size_;
};
endsnippet

snippet algbuildtree "Build tree from a undirected graph and a root index"
vector<vector<int>> buildTree(const vector<vector<int>>& edges, int root) {
	int N = edges.size();
	vector<vector<int>> tree(N);
	vector<int> visited(N, false);
	vector<int> st;
	st.push_back(root);
	while (!st.empty()) {
		int u = st.back(); st.pop_back();
		if (visited[u]) {
			continue;
		}
		visited[u] = true;
		for (int v : edges[u]) {
			if (visited[v]) {
				continue;
			}
			tree[u].push_back(v);
			st.push_back(v);
		}
	}
	return tree;
}
endsnippet

snippet algtoposort "Topological sort algorithm"
vector<int> topologicalSort(const vector<vector<int>>& graph) {
	size_t N = graph.size();
	vector<int> incomming(N, 0);
	for (int u = 0; u < graph.size(); ++u) {
		for (int v : graph[u]) {
			incomming[v]++;
		}
	}

	queue<int> Q;
	for (int v = 0; v < N; ++v) {
		if (incomming[v] == 0) {
			Q.push(v);
		}
	}

	vector<int> res;
	while (!Q.empty()) {
		int u = Q.front(); Q.pop();
		res.push_back(u);
		for (int v : graph[u]) {
			incomming[v]--;
			if (incomming[v] == 0) {
				Q.push(v);
			}
		}
	}
	return res;
}
endsnippet

snippet clssparsetable "Sparse table, datastructure"
class SparseTable {
 public:
	vector<vector<int>> table_;
	int maxDepth_;

 public:
	SparseTable(const vector<int>& f, int maxDepth = 20)
			: table_(maxDepth), maxDepth_(maxDepth) {
		table_[0] = f;
		for (int i = 1; i < maxDepth; ++i) {
			const vector<int>& prev = table_[i - 1];
			vector<int>& row = table_[i];
			row.resize(prev.size());
			for (int j = 0; j < row.size(); ++j) {
				row[j] = prev[prev[j]];
			}
		}
	}

	int query(int n, int x) const {
		for (int i = 0; i < maxDepth_; ++i) {
			if ((n >> i) & 1) {
				x = table_[i][x];
			}
		}
		return x;
	}
};
endsnippet


snippet alglca "lowest common ancestor algorithm"
class SparseTable {
	vector<vector<int>> table_;
	int maxDepth_;

 public:
	SparseTable(const vector<int>& f, int maxDepth = 20)
			: table_(maxDepth), maxDepth_(maxDepth) {
		table_[0] = f;
		for (int i = 1; i < maxDepth; ++i) {
			const vector<int>& prev = table_[i - 1];
			vector<int>& row = table_[i];
			row.resize(prev.size());
			for (int j = 0; j < row.size(); ++j) {
				row[j] = prev[prev[j]];
			}
		}
	}

	SparseTable() {}

	int query(int n, int x) const {
		for (int i = 0; i < maxDepth_; ++i) {
			if ((n >> i) & 1) {
				x = table_[i][x];
			}
		}
		return x;
	}
};

class LCA {
	vector<int> depth_;
	int logMaxDepth_;
	SparseTable parent_;
 public:
	LCA(const vector<int>& parent, const vector<int>& depth) : depth_(depth) {
		int maxDepth = 1;
		for (auto d : depth) {
			maxDepth = max(d, maxDepth);
		}
		logMaxDepth_ = log2(maxDepth) + 1;
		parent_ = SparseTable(parent, logMaxDepth_);
	}

	int query(int u, int v) {
		if (depth_[u] < depth_[v]) {
			swap(u, v);
		}

		if (depth_[u] != depth_[v]) {
			u = parent_.query(depth_[u] - depth_[v], u);
		}

		for (int i = logMaxDepth_; i >= 0; --i) {
			int u2 = parent_.query(1<<i, u);
			int v2 = parent_.query(1<<i, v);
			if (u2 != v2 && u2 != 0) {
				u = u2;
				v = v2;
			}
		}
		if (u != v) {
			u = parent_.query(1, u);
			v = parent_.query(1, v);
		}
		return u;
	}
};
endsnippet

snippet algtarjanscc "Tarjan's strongly connected components algorithm"
vector<vector<int>> tarjanSCC(const vector<vector<int>>& edges) {
	struct Vertex {
		int vid;
		int index = -1;
		bool processed = false;
	};
	vector<vector<int>> res;
	stack<Vertex*> S;
	vector<Vertex> vertices(edges.size());
	for (int i = 0; i < edges.size(); ++i) {
		vertices[i].vid = i;
	}
	int index = 0;

	function<int(Vertex&)> dfs = [&](Vertex& v) -> int {
		v.index = index++;
		S.push(&v);
		int parent = v.index;
		for (int nxt : edges[v.vid]) {
			Vertex& w = vertices[nxt];
			if (w.index == -1) {
				parent = min(parent, dfs(w));
			} else if (!w.processed) {
				parent = min(parent, w.index);
			}
		}
		if (parent == v.index) {
			vector<int> newSCC;
			Vertex* w;
			do {
				w = S.top();
				S.pop();
				w->processed = true;
				newSCC.push_back(w->vid);
			} while (w->vid != v.vid);
			res.push_back(newSCC);
		}
		return parent;
	};

	for (auto& v : vertices) {
		if (v.index == -1) {
			dfs(v);
		}
	}

	return res;
}
endsnippet

snippet alg2sat "2-SAT solver"
vector<bool> twoSAT(const vector<vector<int>>& graph,
										const function<int(int)>& neg) {
	auto sccs = tarjanSCC(graph);
	size_t N = graph.size() / 2;

	vector<int> sccGroup(graph.size());
	for (int i = 0; i < sccs.size(); ++i) {
		const auto& scc = sccs[i];
		for (int j : scc) {
			sccGroup[j] = i;
		}
	}

	for (int i = 0; i < N; ++i) {
		if (sccGroup[i] == sccGroup[neg(i)]) {
			return {};
		}
	}

	vector<bool> res(N);
	for (int i = 0; i < res.size(); ++i) {
		res[i] = sccGroup[i] < sccGroup[neg(i)];
	}
	return res;
}
endsnippet

snippet algbipartite "Bipartite matching algorithm"
class BipartiteMatching {
 public:
	const vector<vector<int>>& edges_;
	size_t nDst_;
	vector<int> matches_;
	vector<bool> visited_;

 public:
	BipartiteMatching(const vector<vector<int>>& edges, int nDst = -1)
			: edges_(edges), nDst_(nDst) {
		if (nDst_ == -1) {
			nDst_ = 0;
			for (int i = 0; i < edges.size(); ++i) {
				for (int w : edges[i]) {
					nDst_ = max(nDst_, (size_t)(w+1));
				}
			}
		}
		matches_.resize(nDst, -1);
		visited_.resize(nDst, false);
	}

	size_t solve() {
		size_t res = 0;
		for (size_t i = 0; i < edges_.size(); ++i) {
			fill(all(visited_), false);
			res += dfs(i);
		}
		return res;
	}

	std::vector<std::pair<int, int>> matches() const {
		std::vector<std::pair<int, int>> res;
		for (size_t dst = 0; dst < matches_.size(); ++dst) {
			const auto& src = matches_[dst];
			if (src != -1) {
				res.push_back({src, dst});
			}
		}
		return res;
	}

 private:
	bool dfs(int src) {
		for (int dst : edges_[src]) {
			if (visited_[dst]) {
				continue;
			}
			visited_[dst] = true;
			if (matches_[dst] == -1 || dfs(matches_[dst])) {
				matches_[dst] = src;
				return true;
			}
		}
		return false;
	}
};
endsnippet


snippet algmaxflow "Edmond-Karp, max flow algorithm."
class MaxFlow {
 public:
	int N_;
	vector<vector<int>> cap_;
	vector<vector<int>> flow_;
	vector<list<int>> graph_;

	int src_;
	int sink_;

	MaxFlow(int N)
			: N_(N),
				cap_(vector<vector<int>>(N, vector<int>(N, 0))),
				flow_(vector<vector<int>>(N, vector<int>(N, 0))),
				graph_(vector<list<int>>(N)) {}

	void setEdge(int u, int v, int cap) {
		cap_[u][v] = cap;
		graph_[u].push_back(v);
		graph_[v].push_back(u);
	}

	void setSrcSink(int src, int sink) {
		src_ = src;
		sink_ = sink;
	}
	
	int solve() {
		int res = 0;
		while (true) {
			vector<int> trace = findPath();
			if (trace[sink_] == -1) {
				break;
			}
			int flow = numeric_limits<int>::max();
			for (int v = sink_; v != src_; v = trace[v]) {
				int u = trace[v];
				flow = min(flow, cap_[u][v] - flow_[u][v]);
			}
			for (int v = sink_; v != src_; v = trace[v]) {
				int u = trace[v];
				flow_[u][v] += flow;
				flow_[v][u] -= flow;
			}
			res += flow;
		}
		return res;
	}

 private:
	vector<int> findPath() {
		queue<int> Q;
		vector<int> trace(N_, -1);
		Q.push(src_);
		while (!Q.empty()) {
			int u = Q.front(); Q.pop();
			for (int v : graph_[u]) {
				if (flow_[u][v] < cap_[u][v] && trace[v]==-1) {
					trace[v] = u;
					Q.push(v);
					if (v == sink_) {
						return trace;
					}
				}
			}			 
		}
		return trace;
	}
};
endsnippet
