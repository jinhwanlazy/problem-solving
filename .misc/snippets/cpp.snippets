snippet main "The main function"
#include <bits/stdc++.h>
#define all(x) (x).begin(), (x).end()

using namespace std;
using LL = long long;

$0
int main() {

	return 0;
}
endsnippet

snippet inf "pseudo infinity"
constexpr static ${1:int} INF = numeric_limits<${1}>::max();
$0
endsnippet

snippet dirs "4 directions in grid"
constexpr static int di[4] = {0, 0, -1, +1};
constexpr static int dj[4] = {-1, +1, 0, 0};
$0
endsnippet

snippet boundcheck "check if value is within bound"
inline bool boundCheck(int i, int max_i) {
	return 0 <= i && i < max_i;
}

inline bool boundCheck(int i, int min_i, int max_i) {
	return min_i <= i && i < max_i;
}

endsnippet

snippet boundcheck2 "check if value is within bound"
inline bool boundCheck(int i, int max_i) {
	return 0 <= i && i < max_i;
}

inline bool boundCheck(int i, int min_i, int max_i) {
	return min_i <= i && i < max_i;
}

inline bool boundCheck2d(int i, int j, int max_i, int max_j) {
	return boundCheck(i, max_i) && boundCheck(j, max_j);
}

inline bool boundCheck2d(int i, int j, int min_i, int min_j, int max_i, int max_j) {
	return boundCheck(i, min_i, max_i) && boundCheck(j, min_j, max_j);
}
endsnippet

snippet boundcheck3 "check if value is within bound"
inline bool boundCheck(int i, int max_i) {
	return 0 <= i && i < max_i;
}

inline bool boundCheck(int i, int min_i, int max_i) {
	return min_i <= i && i < max_i;
}

inline bool boundCheck3d(int i, int j, int k, int max_i, int max_j, int max_k) {
	return boundCheck(i, max_i) && boundCheck(j, max_j) && boundCheck(k, max_k);
}

inline bool boundCheck3d(int i, int j, int k, int min_i, int min_j, int min_k, int max_i, int max_j, int max_k) {
	return boundCheck(i, min_i, max_i) && boundCheck(j, min_j, max_j) && boundCheck(k, min_k, max_k);
}
endsnippet

snippet algsieve "Sieve of Eratosthenes"
struct Sieve
{
	Sieve(size_t max_size) : data_(max_size, true) {
		data_[0] = false;
		data_[1] = false;
		for (size_t i = 2; i < max_size; ++i) {
			if (!data_[i]) {
				continue;
			}
			for (size_t j = i * 2; j < max_size; j += i) {
				data_[j] = false;
			}
		}
	}
	
	bool isPrime(size_t i) {
		return data_[i];
	}
	
	vector<bool> data_;
};
endsnippet

snippet alglcs "LCS, longest common subsequence algorithm. solution of boj_9252"
int LCS(const string& A, const string& B, string* trace=nullptr) 
{
	/*
	 * dp[i][j] := LCS(A[:i], B[:j])
	 */
	vector<vector<int>> dp(A.size()+1, vector<int>(B.size()+1, 0));
	for (int i = 1; i <= A.size(); ++i) {
		for (int j = 1; j <= B.size(); ++j) {
			if (A[i-1] == B[j-1]) {
				dp[i][j] = dp[i-1][j-1] + 1;
			}
			else {
				dp[i][j] = max(dp[i][j-1], dp[i-1][j]);
			}
		}
	}
	
	if (trace != nullptr) {
		int i = A.size();
		int j = B.size();
		trace->clear();
		while (i > 0 && j > 0) {
			if (A[i-1] == B[j-1]) {
				trace->push_back(A[i-1]);
				i--;
				j--;
			}
			else if (dp[i-1][j] == dp[i][j]) {
				i--;
			}
			else if (dp[i][j-1] == dp[i][j]) {
				j--;
			}
		}
		reverse(trace->begin(), trace->end());
	}
	return dp.back().back();
}
endsnippet

snippet clssegtree "Segment tree class, solution of boj_2042"
template<typename T>
class SegTree {
 private:
	vector<T> tree_;
	size_t n_;

 public:
	template <typename U>
	SegTree(const size_t size, const U& default_value)
			: SegTree(vector<U>(size, default_value)) {}

	template <typename U>
	SegTree(const vector<U>& data) {
		n_ = data.size();
		tree_.resize(4 * n_);
		std::fill(tree_.begin(), tree_.end(), falseValue());
		init(data, 0, n_ - 1, 1);
	}

	T query(size_t left, size_t right) {
		return query(left, right, 1, 0, n_ - 1);
	}

	template <typename U>
	T update(size_t idx, const U& new_value) {
		return update(idx, new_value, 1, 0, n_ - 1);
	}

 private:
	template <typename U>
	T init(const vector<U>& data, size_t left, size_t right, size_t node_idx) {
		if (left == right) {
			return tree_[node_idx] = transform(data[left]);
		}
		size_t mid = (left + right) / 2;
		T res_left = init(data, left, mid, node_idx * 2);
		T res_right = init(data, mid + 1, right, node_idx * 2 + 1);
		return tree_[node_idx] = aggregate(res_left, res_right);
	}

	T query(size_t left,
					size_t right,
					size_t node_idx,
					size_t node_left,
					size_t node_right) {
		if (right < node_left || node_right < left) {
			return falseValue();
		}
		if (left <= node_left && node_right <= right) {
			return tree_[node_idx];
		}
		size_t mid = (node_left + node_right) / 2;
		T res_left = query(left, right, node_idx * 2, node_left, mid);
		T res_right = query(left, right, node_idx * 2 + 1, mid + 1, node_right);
		return aggregate(res_left, res_right);
	}

	template <typename U>
	T update(size_t idx,
					 const U& new_value,
					 size_t node_idx,
					 size_t node_left,
					 size_t node_right) {
		if (idx < node_left || node_right < idx) {
			return tree_[node_idx];
		}
		if (node_left == node_right) {
			return tree_[node_idx] = transform(new_value);
		}
		size_t mid = (node_left + node_right) / 2;
		T res_left = update(idx, new_value, node_idx * 2, node_left, mid);
		T res_right = update(idx, new_value, node_idx * 2 + 1, mid + 1, node_right);
		return tree_[node_idx] = aggregate(res_left, res_right);
	}

	template <typename U>
	static T transform(const U& v) {
		return v;
	}

	static T aggregate(const T& lhs, const T& rhs) { return lhs + rhs; }

	static T falseValue() { return 0; }
};
endsnippet

snippet clsfenwicktree "binary indexed tree class, solution of boj_2042"
template <typename T>
class FenwickTree {
 public:
	vector<T> arr_;
	vector<T> tree_;

 public:
	FenwickTree(size_t n) 
		: arr_(n, defaultValue()) 
		, tree_(n, defaultValue()) 
	{}

	FenwickTree(const vector<T>& arr) {
		init(arr);
	}

 public:
	void update(int i, const T& val) {
		T diff = val - arr_[i];
		arr_[i] = val;
		while (i < tree_.size()) {
			tree_[i] += diff;
			i += LSB(i);
		}
	}

	T query(int i) {
		T res = defaultValue();
		while (i > 0) {
			res += tree_[i];
			i -= LSB(i);
		}
		return res;
	}

	T query(int i, int j) {
		T res = defaultValue();
		for (i--; j > i; j -= LSB(j)) {
			res += tree_[j];
		}
		for (; i > j; i -= LSB(i)) {
			res -= tree_[i];
		}
		return res;
	}

	static inline T defaultValue() {
		return 0;
	}

	static inline int LSB(int i) { return i & (-i); }

 private:
	void init(const vector<T>& arr) {
		arr_ = arr;
		tree_ = arr;
		for (int i = 1; i < tree_.size(); ++i) {
			int j = i + LSB(i);
			if (j < tree_.size())
				tree_[j] += tree_[i];
		}
	}
};
endsnippet

snippet clscountingsegtree "Counting Segment tree, solution of boj_7626"
template<typename T>
class CountingSegTree {
 public:
	vector<T> tree_;
	size_t n_;

	vector<int> count_;

 public:
	CountingSegTree(size_t size) {
		n_ = size;
		tree_.resize(4 * n_, 0);
		count_.resize(4 * n_, 0);
	}

	T query(size_t left, size_t right) {
		return query(left, right, 1, 0, n_ - 1);
	}

	void updateRange(size_t left, size_t right, int inc, 
			const function<T(int, size_t, size_t)>& transform) {
		updateRange(left, right, inc, 1, 0, n_ - 1, transform);
	}

 private:
	T query(size_t left,
					size_t right,
					size_t node_idx,
					size_t node_left,
					size_t node_right) {
		if (right < node_left || node_right < left) {
			return 0;
		}
		if (left <= node_left && node_right <= right) {
			return tree_[node_idx];
		}
		size_t mid = (node_left + node_right) / 2;
		T res_left = query(left, right, node_idx * 2, node_left, mid);
		T res_right = query(left, right, node_idx * 2 + 1, mid + 1, node_right);
		return aggregate(res_left, res_right);
	}

	void updateRange(
			size_t left, 
			size_t right,
			const int& inc,
			size_t node_idx,
			size_t node_left,
			size_t node_right, 
			const function<T(int, size_t, size_t)>& transform) {
		if (right < node_left || node_right < left) {
			return;
		}
		if (left <= node_left && node_right <= right) {
			count_[node_idx] += inc;
		}
		else {
			size_t mid = (node_left + node_right) / 2;
			updateRange(left, right, inc, node_idx * 2, node_left, mid, transform);
			updateRange(left, right, inc, node_idx * 2 + 1, mid+1, node_right, transform);
		}

		if (count_[node_idx]) {
			tree_[node_idx] = transform(0, node_left, node_right);
		}
		else if (node_left == node_right) {
			tree_[node_idx] = 0;
		}
		else {
			tree_[node_idx] = aggregate(tree_[node_idx * 2], tree_[node_idx * 2 + 1]);
		}
	}

	static T aggregate(const T& lhs, const T& rhs) { return lhs + rhs; }
};
endsnippet
