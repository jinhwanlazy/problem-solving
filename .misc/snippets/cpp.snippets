snippet main "The main function"
#include <bits/stdc++.h> 
using namespace std;

int main()
{
	$0
	return 0;
}
endsnippet

snippet readi "read an integer"
int ${1:N};
scanf("%d", &$1);
$0
endsnippet

snippet readii "read two integers"
int ${1:N}, ${2:M};
scanf("%d %d", &$1, &$2);
$0
endsnippet

snippet readiii "read three integers"
int ${1:A}, ${2:B}, ${3:C};
scanf("%d %d %d", &$1, &$2, &$3);
$0
endsnippet

snippet readv "read a vector"
vector<${1:int}> ${2:xs}(${3:N});
for (int i = 0; i < $3; ++i) {
	scanf("%d", &$2[i]);
}
$0
endsnippet

snippet readvv "read a vector of vector"
vector<vector<${1:int}>> ${2:grid}(${3:N}, vector<$1>(${4:M}));
for (int i = 0; i < $3; ++i) {
	for (int j = 0; j < $4; ++j) {
		scanf("%d", &$2[i][j]);
	}
}
$0
endsnippet

snippet reads "read a string"
string ${1:S};
scanf("%s\n", &$1);
$0
endsnippet


snippet printi "print an integer"
printf("%d\n", $1);
$0
endsnippet

snippet printii "print two integers"
printf("%d %d\n", $1, $2);
$0
endsnippet

snippet printv "print a vector"
for (int i = 0; i < $1.size(); ++i) {
	printf("%d ", $1[i]);
}
$0
endsnippet

snippet printvv "print a 2d vector"
for (int i = 0; i < $1.size(); ++i) {
	for(int j = 0; j < $1[i].size(); ++j) {
		printf("%d ", $1[i][j]);
	}
	printf("\n");
}
$0
endsnippet

snippet inf "pseudo infinity"
constexpr static ${1:int} INF = numeric_limits<${1}>::max();
$0
endsnippet

snippet dirs "4 directions in grid"
constexpr static int di[4] = {0, 0, -1, +1};
constexpr static int dj[4] = {-1, +1, 0, 0};
$0
endsnippet

snippet boundcheck "check if value is within bound"
inline bool boundCheck(int i, int max_i) {
	return 0 <= i && i < max_i;
}

inline bool boundCheck(int i, int min_i, int max_i) {
	return min_i <= i && i < max_i;
}

endsnippet

snippet boundcheck2 "check if value is within bound"
inline bool boundCheck(int i, int max_i) {
	return 0 <= i && i < max_i;
}

inline bool boundCheck(int i, int min_i, int max_i) {
	return min_i <= i && i < max_i;
}

inline bool boundCheck2d(int i, int j, int max_i, int max_j) {
	return boundCheck(i, max_i) && boundCheck(j, max_j);
}

inline bool boundCheck2d(int i, int j, int min_i, int min_j, int max_i, int max_j) {
	return boundCheck(i, min_i, max_i) && boundCheck(j, min_j, max_j);
}
endsnippet

snippet boundcheck3 "check if value is within bound"
inline bool boundCheck(int i, int max_i) {
	return 0 <= i && i < max_i;
}

inline bool boundCheck(int i, int min_i, int max_i) {
	return min_i <= i && i < max_i;
}

inline bool boundCheck3d(int i, int j, int k, int max_i, int max_j, int max_k) {
	return boundCheck(i, max_i) && boundCheck(j, max_j) && boundCheck(k, max_k);
}

inline bool boundCheck3d(int i, int j, int k, int min_i, int min_j, int min_k, int max_i, int max_j, int max_k) {
	return boundCheck(i, min_i, max_i) && boundCheck(j, min_j, max_j) && boundCheck(k, min_k, max_k);
}
endsnippet

snippet algdijkstra "dijkstra shortest path algorithm. solution of boj_13913"
using LL = long long;
constexpr static int INF = numeric_limits<int>::max();

struct State {
	int u;
	LL cost;

	friend bool operator<(const State& lhs, const State& rhs) {
		return lhs.cost > rhs.cost;
	}
};

struct Edge {
	int u;
	int v;
	LL cost;
};

vector<LL> dijkstra(const vector<vector<Edge>>& edges, int src, vector<int> *trace=nullptr) {
	vector<LL> cost(edges.size(), INF);
	if (trace) {
		trace->resize(edges.size());
		fill(trace->begin(), trace->end(), -1);
	}
	priority_queue<State> Q;
	cost[src] = 0;
	Q.push({src, 0});
	while (!Q.empty()) {
		auto [u, c] = Q.top(); Q.pop();
		if (cost[u] < c) {
			continue;
		}
		for (const auto& [_, v, w] : edges[u]) {
			int next_cost = c + w;
			if (next_cost < cost[v]) {
				cost[v] = next_cost;
				Q.push({v, next_cost});
				if (trace) {
					(*trace)[v] = u;
				}
			}
		}
	}
	return cost;
}
endsnippet

snippet algbellman "bellman-ford, shortest path algorithm. solution of boj_11657"
using LL = long long;
constexpr static LL INF = numeric_limits<LL>::max();

struct Edge {
	int u;
	int v;
	LL cost;
};

vector<LL> bellmanFord(const vector<Edge>& edges, int n_vertices, int src) {
	vector<LL> cost(n_vertices+1, INF);
	cost[src] = 0;

	for (int i = 1; i <= edges.size(); ++i) {
		for (const auto& [u, v, c] : edges) {
			if (cost[u] != INF && cost[v] > cost[u] + c) {
				cost[v] = cost[u] + c;
				if (i == edges.size()) {
					return {};
				}
			}
		}
	}
	return cost;
}

endsnippet


snippet algfloyd "floyd-warshall, shortest path algorithm. solution of boj_11404"
using LL = long long;
constexpr static LL INF = numeric_limits<int>::max();

vector<vector<LL>> floydWarshall(const vector<vector<LL>>& adj) {
	size_t N = adj.size()-1;
	auto cost = adj;

	for (int k = 1; k <= N; ++k) {
		for (int i = 1; i <= N; ++i) {
			for (int j = 1; j <= N; ++j) {
				if (cost[i][k] != INF && cost[k][j] != INF) {
					cost[i][j] = min(cost[i][k] + cost[k][j], cost[i][j]);
				}
			}
		}
	}
	return cost;
}
endsnippet

snippet algsieve "Sieve of Eratosthenes"
struct Sieve
{
	Sieve(size_t max_size) : data_(max_size, true) {
		data_[0] = false;
		data_[1] = false;
		for (size_t i = 2; i < max_size; ++i) {
			if (!data_[i]) {
				continue;
			}
			for (size_t j = i * 2; j < max_size; j += i) {
				data_[j] = false;
			}
		}
	}
	
	bool isPrime(size_t i) {
		return data_[i];
	}
	
	vector<bool> data_;
};
endsnippet

