snippet main "The main function"
#include <bits/stdc++.h> 
using namespace std;

int main()
{
	$0
	return 0;
}
endsnippet

snippet readi "read an integer"
int ${1:N};
scanf("%d", &$1);
$0
endsnippet

snippet readii "read two integers"
int ${1:N}, ${2:M};
scanf("%d %d", &$1, &$2);
$0
endsnippet

snippet readiii "read three integers"
int ${1:A}, ${2:B}, ${3:C};
scanf("%d %d %d", &$1, &$2, &$3);
$0
endsnippet

snippet readv "read a vector"
vector<${1:int}> ${2:xs}(${3:N});
for (int i = 0; i < $3; ++i) {
	scanf("%d", &$2[i]);
}
$0
endsnippet

snippet readvv "read a vector of vector"
vector<vector<${1:int}>> ${2:grid}(${3:N}, vector<$1>(${4:M}));
for (int i = 0; i < $3; ++i) {
	for (int j = 0; j < $4; ++j) {
		scanf("%d", &$2[i][j]);
	}
}
$0
endsnippet

snippet reads "read a string"
string ${1:S};
scanf("%s\n", &$1);
$0
endsnippet


snippet printi "print an integer"
printf("%d\n", $1);
$0
endsnippet

snippet printii "print two integers"
printf("%d %d\n", $1, $2);
$0
endsnippet

snippet printv "print a vector"
for (int i = 0; i < $1.size(); ++i) {
	printf("%d ", $1[i]);
}
printf("\n");
$0
endsnippet

snippet printvv "print a 2d vector"
for (int i = 0; i < $1.size(); ++i) {
	for(int j = 0; j < $1[i].size(); ++j) {
		printf("%d ", $1[i][j]);
	}
	printf("\n");
}
$0
endsnippet

snippet inf "pseudo infinity"
constexpr static ${1:int} INF = numeric_limits<${1}>::max();
$0
endsnippet

snippet dirs "4 directions in grid"
constexpr static int di[4] = {0, 0, -1, +1};
constexpr static int dj[4] = {-1, +1, 0, 0};
$0
endsnippet

snippet boundcheck "check if value is within bound"
inline bool boundCheck(int i, int max_i) {
	return 0 <= i && i < max_i;
}

inline bool boundCheck(int i, int min_i, int max_i) {
	return min_i <= i && i < max_i;
}

endsnippet

snippet boundcheck2 "check if value is within bound"
inline bool boundCheck(int i, int max_i) {
	return 0 <= i && i < max_i;
}

inline bool boundCheck(int i, int min_i, int max_i) {
	return min_i <= i && i < max_i;
}

inline bool boundCheck2d(int i, int j, int max_i, int max_j) {
	return boundCheck(i, max_i) && boundCheck(j, max_j);
}

inline bool boundCheck2d(int i, int j, int min_i, int min_j, int max_i, int max_j) {
	return boundCheck(i, min_i, max_i) && boundCheck(j, min_j, max_j);
}
endsnippet

snippet boundcheck3 "check if value is within bound"
inline bool boundCheck(int i, int max_i) {
	return 0 <= i && i < max_i;
}

inline bool boundCheck(int i, int min_i, int max_i) {
	return min_i <= i && i < max_i;
}

inline bool boundCheck3d(int i, int j, int k, int max_i, int max_j, int max_k) {
	return boundCheck(i, max_i) && boundCheck(j, max_j) && boundCheck(k, max_k);
}

inline bool boundCheck3d(int i, int j, int k, int min_i, int min_j, int min_k, int max_i, int max_j, int max_k) {
	return boundCheck(i, min_i, max_i) && boundCheck(j, min_j, max_j) && boundCheck(k, min_k, max_k);
}
endsnippet

snippet clsedge "basic edge struct"
struct Edge
{
	int u;
	int v;
	${1:int} w; /* cost */

	friend bool operator< (const Edge& lhs, const Edge& rhs) {
		return lhs.w > rhs.w;
	}
};
endsnippet

snippet algdijkstra "dijkstra shortest path algorithm. solution of boj_13913"
using LL = long long;
constexpr static int INF = numeric_limits<int>::max();

struct State {
	int u;
	LL cost;

	friend bool operator<(const State& lhs, const State& rhs) {
		return lhs.cost > rhs.cost;
	}
};

struct Edge {
	int u;
	int v;
	LL cost;
};

vector<LL> dijkstra(const vector<vector<Edge>>& edges, int src, vector<int> *trace=nullptr) {
	vector<LL> cost(edges.size(), INF);
	if (trace) {
		trace->resize(edges.size());
		fill(trace->begin(), trace->end(), -1);
	}
	priority_queue<State> Q;
	cost[src] = 0;
	Q.push({src, 0});
	while (!Q.empty()) {
		auto [u, c] = Q.top(); Q.pop();
		if (cost[u] < c) {
			continue;
		}
		for (const auto& [_, v, w] : edges[u]) {
			int next_cost = c + w;
			if (next_cost < cost[v]) {
				cost[v] = next_cost;
				Q.push({v, next_cost});
				if (trace) {
					(*trace)[v] = u;
				}
			}
		}
	}
	return cost;
}
endsnippet

snippet algbellman "bellman-ford, shortest path algorithm. solution of boj_11657"
using LL = long long;
constexpr static LL INF = numeric_limits<LL>::max();

struct Edge {
	int u;
	int v;
	LL cost;
};

vector<LL> bellmanFord(const vector<Edge>& edges, int n_vertices, int src) {
	vector<LL> cost(n_vertices+1, INF);
	cost[src] = 0;

	for (int i = 1; i <= edges.size(); ++i) {
		for (const auto& [u, v, c] : edges) {
			if (cost[u] != INF && cost[v] > cost[u] + c) {
				cost[v] = cost[u] + c;
				if (i == edges.size()) {
					return {};
				}
			}
		}
	}
	return cost;
}

endsnippet


snippet algfloyd "floyd-warshall, shortest path algorithm. solution of boj_11404"
using LL = long long;
constexpr static LL INF = numeric_limits<int>::max();

vector<vector<LL>> floydWarshall(const vector<vector<LL>>& adj) {
	size_t N = adj.size()-1;
	auto cost = adj;

	for (int k = 1; k <= N; ++k) {
		for (int i = 1; i <= N; ++i) {
			for (int j = 1; j <= N; ++j) {
				if (cost[i][k] != INF && cost[k][j] != INF) {
					cost[i][j] = min(cost[i][k] + cost[k][j], cost[i][j]);
				}
			}
		}
	}
	return cost;
}
endsnippet

snippet algsieve "Sieve of Eratosthenes"
struct Sieve
{
	Sieve(size_t max_size) : data_(max_size, true) {
		data_[0] = false;
		data_[1] = false;
		for (size_t i = 2; i < max_size; ++i) {
			if (!data_[i]) {
				continue;
			}
			for (size_t j = i * 2; j < max_size; j += i) {
				data_[j] = false;
			}
		}
	}
	
	bool isPrime(size_t i) {
		return data_[i];
	}
	
	vector<bool> data_;
};
endsnippet

snippet alglcs "LCS, longest common subsequence algorithm. solution of boj_9252"
int LCS(const string& A, const string& B, string* trace=nullptr) 
{
	/*
	 * dp[i][j] := LCS(A[:i], B[:j])
	 */
	vector<vector<int>> dp(A.size()+1, vector<int>(B.size()+1, 0));
	for (int i = 1; i <= A.size(); ++i) {
		for (int j = 1; j <= B.size(); ++j) {
			if (A[i-1] == B[j-1]) {
				dp[i][j] = dp[i-1][j-1] + 1;
			}
			else {
				dp[i][j] = max(dp[i][j-1], dp[i-1][j]);
			}
		}
	}
	
	if (trace != nullptr) {
		int i = A.size();
		int j = B.size();
		trace->clear();
		while (i > 0 && j > 0) {
			if (A[i-1] == B[j-1]) {
				trace->push_back(A[i-1]);
				i--;
				j--;
			}
			else if (dp[i-1][j] == dp[i][j]) {
				i--;
			}
			else if (dp[i][j-1] == dp[i][j]) {
				j--;
			}
		}
		reverse(trace->begin(), trace->end());
	}
	return dp.back().back();
}
endsnippet

snippet algunionfind "Union Find Set data structure. solution of boj_4195"
struct UnionFindSet {
	UnionFindSet(int size) : root_(size), rank_(size, 0), size_(size, 1) {
		for (int i = 0; i < size; ++i) {
			root_[i] = i;
		}
	}

	int find(int i) {
		if (root_[i] == i) {
			return i;
		}
		int root = find(root_[i]);
		root_[i] = root;
		return root;
	}

	int merge(int i, int j) {
		int i_root = find(i);
		int j_root = find(j);
		if (i_root == j_root) {
			return size_[i_root];
		}
		if (rank_[i_root] < rank_[j_root]) {
			root_[i_root] = j_root;
			size_[j_root] += size_[i_root];
			size_[i_root] = 0;
			return size_[j_root];
		}
		root_[j_root] = i_root;
		size_[i_root] += size_[j_root];
		size_[j_root] = 0;
		if (rank_[i_root] == rank_[j_root]) {
			rank_[i_root]++;
		}
		return size_[i_root];
	}

	bool resize(size_t size) {
		size_t size_before = root_.size();

		if (size_before >= size) {
			return false;
		}
		root_.resize(size);
		rank_.resize(size, 0);
		size_.resize(size, 1);
		for (size_t i = size_before; i < size; ++i) {
			root_[i] = i;
		}
		return true;
	}

	size_t size() const {
		return root_.size();
	}

	vector<int> root_;
	vector<int> rank_;
	vector<int> size_;
};
endsnippet

snippet clsvec2 "2D Vector class"
class Vec2
{
public:
	using T = double;

public:
	T x;
	T y;

public:
	inline Vec2& operator= (const Vec2& rhs)
	{
		x = rhs.x;
		y = rhs.y;
		return *this;
	}

public:
	inline bool operator==(const Vec2& rhs) const
	{
		return ((x == rhs.x) && (y == rhs.y));
	}

	inline bool operator!=(const Vec2& rhs) const
	{
		return !(operator==(rhs));
	}

	inline Vec2 operator+ (const Vec2& rhs) const
	{
		return Vec2(x + rhs.x, y + rhs.y);
	}

	inline Vec2 operator- (const Vec2& rhs) const
	{
		return Vec2(x - rhs.x, y - rhs.y);
	}

	inline Vec2 operator* (T rhs) const
	{
		return Vec2(T(x * rhs), T(y * rhs));
	}

	inline Vec2 operator/ (T rhs) const
	{
		return Vec2(T(x / rhs), T(y / rhs));
	}

	inline Vec2 operator- () const
	{
		return Vec2(-x, -y);
	}

	inline Vec2& operator+= (const Vec2& rhs)
	{
		x += rhs.x;
		y += rhs.y;
		return *this;
	}

	inline Vec2& operator-= (const Vec2& rhs)
	{
		x -= rhs.x;
		y -= rhs.y;
		return *this;
	}

	inline Vec2& operator*= (T rhs)
	{
		x = T(x * rhs);
		y = T(y * rhs);
		return *this;
	}

	inline Vec2& operator/= (T rhs)
	{
		x = T(x / rhs);
		y = T(y / rhs);
		return *this;
	}

public:
	inline double norm() const
	{
		return sqrt(squaredNorm());
	}

	inline T squaredNorm() const
	{
		return ((x * x) + (y * y));
	}

	inline double length() const 
	{
		return norm();
	}

	inline double length(const Vec2& pos) const
	{
		return sqrt(squaredLength(pos));
	}

	inline T squaredLength() const 
	{
		return squaredNorm();
	}

	inline T squaredLength(const Vec2& pos) const
	{
		return (((x - pos.x) * (x - pos.x)) + ((y - pos.y) * (y - pos.y)));
	}
	
	inline T l1length() const {
		return abs(x) + abs(y);
	}

	inline T l1length(const Vec2& pos) const {
		return abs(x - pos.x) + abs(y - pos.x);
	}

	inline void normalize()
	{
		double l = norm();
		if (l < numeric_limits<double>::epsilon()) {
			x = 0;
			y = 0;
		}
		else {
			x = (T)(x / l);
			y = (T)(y / l);
		}
	}

	inline Vec2 normalized() const
	{
		Vec2 n(*this);
		n.normalize();
		return n;
	}

	inline T dot(const Vec2& rhs) const
	{
		return x * rhs.x + y * rhs.y;
	}

	inline T cross(const Vec2& rhs) const
	{
		return x * rhs.y - y * rhs.x;
	}


public:
	static const Vec2& xAxis() { static Vec2 vec(1, 0); return vec; }
	static const Vec2& yAxis() { static Vec2 vec(0, 1); return vec; }
	static const Vec2& zero() { static Vec2 vec(0, 0); return vec; }
	friend ostream& operator<< (ostream& ostr, const Vec2& rhs) {
		ostr << setprecision(15) << rhs.x << " " << rhs.y;
		return ostr;
	}

	friend istream& operator>> (istream& istr, Vec2& rhs) {
		istr >> rhs.x >> rhs.y;
		return istr;
	}

public:
	Vec2() : x(T(0)), y(T(0)) {}

	Vec2(T x_, T y_) : x(x_), y(y_) {}

	Vec2(const Vec2& rhs) : x(rhs.x), y(rhs.y) {}

	~Vec2() {}

public:
	// To find orientation of ordered triplet (p, q, r). 
	// The function returns following values 
	// 0 --> p, q and r are colinear 
	// +1 --> Clockwise 
	// -1 --> Counterclockwise 
	static int orientation(const Vec2& p, const Vec2& q, const Vec2& r)
	{
		// https://www.geeksforgeeks.org/orientation-3-ordered-points/
		T val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
		if (val == 0) {
			return 0;
		}
		return val > 0 ? 1 : -1;
	}

	// Given three colinear points p, q, r, the function checks if 
	// point q lies on line segment 'pr' 
	static bool onSegment(const Vec2 p, const Vec2 q, const Vec2 r)
	{
		return q.x <= max(p.x, r.x) 
			&& q.x >= min(p.x, r.x) 
			&& q.y <= max(p.y, r.y) 
			&& q.y >= min(p.y, r.y);
	}
};
endsnippet

snippet clsseg2 "2D Segment class"
class Seg2
{
public:
	Vec2 start;
	Vec2 end;

public:
	Vec2 center() const { return (start + end) / 2;}

	Vec2 direction() const { return end - start; }

	Vec2 normalizedDirection() const { return direction().normalized(); }

	double length() const { return (end - start).length(); }

public:
	bool contains(const Vec2& point) const {
		static constexpr double epsilon = 1e-10;
		return Vec2::onSegment(start, point, end) && 
			(start - point).cross(point - end) < epsilon;
	}

	bool contains(const Seg2& rhs) const {
		return contains(rhs.start) && contains(rhs.end);
	}

	bool intersects(const Seg2& rhs) const {
		const auto& p1 = this->start;
		const auto& q1 = this->end;
		const auto& p2 = rhs.start;
		const auto& q2 = rhs.end;

		int o1 = Vec2::orientation(p1, q1, p2); 
		int o2 = Vec2::orientation(p1, q1, q2); 
		int o3 = Vec2::orientation(p2, q2, p1); 
		int o4 = Vec2::orientation(p2, q2, q1); 

		if (o1 * o2 < 0 && o3 * o4 < 0) 
			return true; 

		if (o1 == 0 && Vec2::onSegment(p1, p2, q1)) return true; 
		if (o2 == 0 && Vec2::onSegment(p1, q2, q1)) return true; 
		if (o3 == 0 && Vec2::onSegment(p2, p1, q2)) return true; 
		if (o4 == 0 && Vec2::onSegment(p2, q1, q2)) return true; 
		return false;
	}

	bool colinear(const Seg2& rhs) const {
		// https://stackoverflow.com/a/565282
		const auto& p = this->start;
		const auto r = this->end - this->start;
		const auto& q = rhs.start;
		const auto s = rhs.end - rhs.start;

		auto a = r.cross(s);
		auto b = (q - p).cross(r);
		return a == 0 && b == 0;
	}
	
	Vec2 intersection(const Seg2& rhs) const {
		// https://stackoverflow.com/a/565282
		const auto& p = this->start;
		const auto r = this->end - this->start;
		const auto& q = rhs.start;
		const auto s = rhs.end - rhs.start;

		auto a = r.cross(s);
		auto b = (q - p).cross(r);
		if (a == 0 && b == 0) {
			// case1: colinear
			if (this->contains(rhs.start)) {
				return rhs.start;
			}
			else {
				return rhs.end;
			}
		} else if (a == 0 && b != 0) {
			// case2: parallel
			throw runtime_error("case 2. should be checked using intersects() before");
		}
		double t = (q - p).cross(s) / a;
		double u = (q - p).cross(r) / a;
		if (0 <= t && t <= 1.0 && 0 <= u && u <= 1.0) {
			// case3: intersects
			return p + r * t;
		}
		else {
			// case 4: not parallel but do not intersects
			throw runtime_error("case 4. should be checked using intersects() before");
		}
	}

public:
	friend ostream& operator<< (ostream& ostr, const Seg2& rhs) {
		ostr << "Seg2(" << rhs.start << ", " << rhs.end << ")";
		return ostr;
	}

	friend istream& operator>> (istream& istr, Seg2& rhs) {
		istr >> rhs.start >> rhs.end;
		return istr;
	}
	

public:
	Seg2() {};

	Seg2(const Vec2& start, const Vec2& end) 
		: start(start), end(end) {};

	Seg2(Vec2::T startX, Vec2::T startY, Vec2::T endX, Vec2::T endY) 
		: start{startX, startY}, end{endX, endY} {};

	Seg2(const Seg2& rhs) 
		: start(rhs.start), end(rhs.end) {};

public:
	~Seg2() {}
};
endsnippet

snippet clscircle "2D Circle class"
class Circle
{
	using T = Vec2::T;
	
	Vec2 center;
	T radius;
public:
	inline bool operator==(const Circle& rhs) const {
		return ((center == rhs.center) && (radius == rhs.radius));
	}

public:
	double area() const { return radius * radius * M_PI; }

public:
	bool contains(const Circle& rhs) const {
		return radius >= (center.length(rhs.center) + rhs.radius);
	}

	bool overlaps(const Circle& rhs) const {
		double d = center.length(rhs.center);
		return d < radius + rhs.radius;
		//return abs(radius - rhs.radius) < d && d < radius + rhs.radius;
	}

	optional<pair<Vec2, Vec2>> intersection(const Circle& rhs) const {
		// http://paulbourke.net/geometry/circlesphere/
		if (*this == rhs) {
			return nullopt;
		}
		const Vec2& p0 = this->center;
		const Vec2& p1 = rhs.center;
		double r0 = this->radius;
		double r1 = rhs.radius;
		double d = p0.length(p1);

		if (d >= r0 + r1) {
			return nullopt;
		}
		if (d <= abs(r0 - r1)) {
			return nullopt;
		}

		double a = (r0*r0 - r1*r1 + d*d) / (2 * d);
		double h = sqrt(r0*r0 - a*a);
		Vec2 p2 = p0 + (p1 - p0) * (a / d);
		Vec2 diff = Vec2{p1.y-p0.y, p1.x-p0.x} * h / d;
		return make_pair(p2 + diff, p2 - diff);
	}

	double overlappingArea(const Circle& rhs) const {
		if (!overlaps(rhs)) {
			return 0;
		}
		if (rhs.contains(*this)) {
			return area();
		}
		if (this->contains(rhs)) {
			return rhs.area();
		}
		const double& r0 = radius;
		const double& r1 = rhs.radius;
		const double d = center.length(rhs.center);
		const double angle0 = acos((r0 * r0 + d * d - r1 * r1) / (2 * r0 * d));
		const double angle1 = acos((r1 * r1 + d * d - r0 * r0) / (2 * r1 * d));
		const double rr0 = radius * radius;
		const double rr1 = rhs.radius * rhs.radius;

		double ans = 
			+ rr0 * angle0 - rr0 * sin(2*angle0) * 0.5
			+ rr1 * angle1 - rr1 * sin(2*angle1) * 0.5;
		return ans;
	}

public:
	friend istream& operator>> (istream& istr, Circle& rhs) {
		istr >> rhs.center.x >> rhs.center.y >> rhs.radius;
		return istr;
	}

public:
	Circle() : center(0, 0), radius(T(0)) {}

	Circle(T x, T y, T r) : center(x, y), radius(r) {}

	Circle(const Circle& rhs) : center(rhs.center), radius(rhs.radius) {}

	~Circle() {}
};
endsnippet

snippet algshoelace "the shoelace algorithm, that calculates area of the 2d polygon"
double shoelace(const vector<Point2>& points) {
	double res = 0;
	for (int i = 0; i <= points.size(); ++i) {
		res += points[i].x * points[(i+1) % points.size()].y;
		res -= points[i].y * points[(i+1) % points.size()].x;
	}
	return 0.5 * abs(res);
}
endsnippet

snippet algbuildtree "Build tree from a undirected graph and a root index"
vector<vector<int>> buildTree(const vector<vector<int>>& edges, int root) {
	int N = edges.size();
	vector<vector<int>> tree(N);
	vector<int> visited(N, false);
	vector<int> st;
	st.push_back(root);
	while (!st.empty()) {
		int u = st.back(); st.pop_back();
		if (visited[u]) {
			continue;
		}
		visited[u] = true;
		for (int v : edges[u]) {
			if (visited[v]) {
				continue;
			}
			tree[u].push_back(v);
			st.push_back(v);
		}
	}
	return tree;
}
endsnippet
