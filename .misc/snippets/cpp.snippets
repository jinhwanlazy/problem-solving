snippet main "The main function"
#include <bits/stdc++.h>
#define all(x) (x).begin(), (x).end()

using namespace std;
using LL = long long;

$0
int main() {

	return 0;
}
endsnippet

snippet readi "read an integer"
int ${1:N};
scanf("%d", &$1);
$0
endsnippet

snippet readii "read two integers"
int ${1:N}, ${2:M};
scanf("%d %d", &$1, &$2);
$0
endsnippet

snippet readiii "read three integers"
int ${1:A}, ${2:B}, ${3:C};
scanf("%d %d %d", &$1, &$2, &$3);
$0
endsnippet

snippet readv "read a vector"
vector<${1:int}> ${2:xs}(${3:N});
for (int i = 0; i < $3; ++i) {
	scanf("%d", &$2[i]);
}
$0
endsnippet

snippet readvv "read a vector of vector"
vector<vector<${1:int}>> ${2:grid}(${3:N}, vector<$1>(${4:M}));
for (int i = 0; i < $3; ++i) {
	for (int j = 0; j < $4; ++j) {
		scanf("%d", &$2[i][j]);
	}
}
$0
endsnippet

snippet reads "read a string"
string ${1:S};
scanf("%s\n", &$1);
$0
endsnippet


snippet printi "print an integer"
printf("%d\n", $1);
$0
endsnippet

snippet printii "print two integers"
printf("%d %d\n", $1, $2);
$0
endsnippet

snippet printiii "print three integers"
printf("%d %d %d\n", $1, $2, $3);
$0
endsnippet

snippet printv "print a vector"
for (int i = 0; i < $1.size(); ++i) {
	printf("%d ", $1[i]);
}
printf("\n");
$0
endsnippet

snippet printvv "print a 2d vector"
for (int i = 0; i < $1.size(); ++i) {
	for(int j = 0; j < $1[i].size(); ++j) {
		printf("%d ", $1[i][j]);
	}
	printf("\n");
}
$0
endsnippet

snippet inf "pseudo infinity"
constexpr static ${1:int} INF = numeric_limits<${1}>::max();
$0
endsnippet

snippet dirs "4 directions in grid"
constexpr static int di[4] = {0, 0, -1, +1};
constexpr static int dj[4] = {-1, +1, 0, 0};
$0
endsnippet

snippet boundcheck "check if value is within bound"
inline bool boundCheck(int i, int max_i) {
	return 0 <= i && i < max_i;
}

inline bool boundCheck(int i, int min_i, int max_i) {
	return min_i <= i && i < max_i;
}

endsnippet

snippet boundcheck2 "check if value is within bound"
inline bool boundCheck(int i, int max_i) {
	return 0 <= i && i < max_i;
}

inline bool boundCheck(int i, int min_i, int max_i) {
	return min_i <= i && i < max_i;
}

inline bool boundCheck2d(int i, int j, int max_i, int max_j) {
	return boundCheck(i, max_i) && boundCheck(j, max_j);
}

inline bool boundCheck2d(int i, int j, int min_i, int min_j, int max_i, int max_j) {
	return boundCheck(i, min_i, max_i) && boundCheck(j, min_j, max_j);
}
endsnippet

snippet boundcheck3 "check if value is within bound"
inline bool boundCheck(int i, int max_i) {
	return 0 <= i && i < max_i;
}

inline bool boundCheck(int i, int min_i, int max_i) {
	return min_i <= i && i < max_i;
}

inline bool boundCheck3d(int i, int j, int k, int max_i, int max_j, int max_k) {
	return boundCheck(i, max_i) && boundCheck(j, max_j) && boundCheck(k, max_k);
}

inline bool boundCheck3d(int i, int j, int k, int min_i, int min_j, int min_k, int max_i, int max_j, int max_k) {
	return boundCheck(i, min_i, max_i) && boundCheck(j, min_j, max_j) && boundCheck(k, min_k, max_k);
}
endsnippet

snippet clsedge "basic edge struct"
struct Edge
{
	int u;
	int v;
	${1:int} w; /* cost */

	friend bool operator< (const Edge& lhs, const Edge& rhs) {
		return lhs.w > rhs.w;
	}
};
endsnippet

snippet algdijkstra "dijkstra shortest path algorithm. solution of boj_13913"
using LL = long long;
constexpr static int INF = numeric_limits<int>::max();

struct State {
	int u;
	LL cost;

	friend bool operator<(const State& lhs, const State& rhs) {
		return lhs.cost > rhs.cost;
	}
};

struct Edge {
	int u;
	int v;
	LL cost;
};

vector<LL> dijkstra(const vector<vector<Edge>>& edges, int src, vector<int> *trace=nullptr) {
	vector<LL> cost(edges.size(), INF);
	if (trace) {
		trace->resize(edges.size());
		fill(trace->begin(), trace->end(), -1);
	}
	priority_queue<State> Q;
	cost[src] = 0;
	Q.push({src, 0});
	while (!Q.empty()) {
		auto [u, c] = Q.top(); Q.pop();
		if (cost[u] < c) {
			continue;
		}
		for (const auto& [_, v, w] : edges[u]) {
			int next_cost = c + w;
			if (next_cost < cost[v]) {
				cost[v] = next_cost;
				Q.push({v, next_cost});
				if (trace) {
					(*trace)[v] = u;
				}
			}
		}
	}
	return cost;
}
endsnippet

snippet algbellman "bellman-ford, shortest path algorithm. solution of boj_11657"
using LL = long long;
constexpr static LL INF = numeric_limits<LL>::max();

struct Edge {
	int u;
	int v;
	LL cost;
};

vector<LL> bellmanFord(const vector<Edge>& edges, int n_vertices, int src) {
	vector<LL> cost(n_vertices+1, INF);
	cost[src] = 0;

	for (int i = 1; i <= edges.size(); ++i) {
		for (const auto& [u, v, c] : edges) {
			if (cost[u] != INF && cost[v] > cost[u] + c) {
				cost[v] = cost[u] + c;
				if (i == edges.size()) {
					return {};
				}
			}
		}
	}
	return cost;
}

endsnippet


snippet algfloyd "floyd-warshall, shortest path algorithm. solution of boj_11404"
using LL = long long;
constexpr static LL INF = numeric_limits<int>::max();

template<typename T>
vector<vector<T>> floydWarshall(const vector<vector<T>>& adj) {
	size_t N = adj.size();
	auto cost = adj;

	for (int k = 0; k < N; ++k) {
		for (int i = 0; i < N; ++i) {
			for (int j = 0; j < N; ++j) {
				if (cost[i][k] != INF && cost[k][j] != INF) {
					cost[i][j] = min(cost[i][k] + cost[k][j], cost[i][j]);
				}
			}
		}
	}
	return cost;
}
endsnippet

snippet algsieve "Sieve of Eratosthenes"
struct Sieve
{
	Sieve(size_t max_size) : data_(max_size, true) {
		data_[0] = false;
		data_[1] = false;
		for (size_t i = 2; i < max_size; ++i) {
			if (!data_[i]) {
				continue;
			}
			for (size_t j = i * 2; j < max_size; j += i) {
				data_[j] = false;
			}
		}
	}
	
	bool isPrime(size_t i) {
		return data_[i];
	}
	
	vector<bool> data_;
};
endsnippet

snippet alglcs "LCS, longest common subsequence algorithm. solution of boj_9252"
int LCS(const string& A, const string& B, string* trace=nullptr) 
{
	/*
	 * dp[i][j] := LCS(A[:i], B[:j])
	 */
	vector<vector<int>> dp(A.size()+1, vector<int>(B.size()+1, 0));
	for (int i = 1; i <= A.size(); ++i) {
		for (int j = 1; j <= B.size(); ++j) {
			if (A[i-1] == B[j-1]) {
				dp[i][j] = dp[i-1][j-1] + 1;
			}
			else {
				dp[i][j] = max(dp[i][j-1], dp[i-1][j]);
			}
		}
	}
	
	if (trace != nullptr) {
		int i = A.size();
		int j = B.size();
		trace->clear();
		while (i > 0 && j > 0) {
			if (A[i-1] == B[j-1]) {
				trace->push_back(A[i-1]);
				i--;
				j--;
			}
			else if (dp[i-1][j] == dp[i][j]) {
				i--;
			}
			else if (dp[i][j-1] == dp[i][j]) {
				j--;
			}
		}
		reverse(trace->begin(), trace->end());
	}
	return dp.back().back();
}
endsnippet

snippet algunionfind "Union Find Set data structure. solution of boj_4195"
struct UnionFindSet {
	UnionFindSet(int size) : root_(size), rank_(size, 0), size_(size, 1) {
		for (int i = 0; i < size; ++i) {
			root_[i] = i;
		}
	}

	int find(int i) {
		if (root_[i] == i) {
			return i;
		}
		int root = find(root_[i]);
		root_[i] = root;
		return root;
	}

	int merge(int i, int j) {
		int i_root = find(i);
		int j_root = find(j);
		if (i_root == j_root) {
			return size_[i_root];
		}
		if (rank_[i_root] < rank_[j_root]) {
			root_[i_root] = j_root;
			size_[j_root] += size_[i_root];
			size_[i_root] = 0;
			return size_[j_root];
		}
		root_[j_root] = i_root;
		size_[i_root] += size_[j_root];
		size_[j_root] = 0;
		if (rank_[i_root] == rank_[j_root]) {
			rank_[i_root]++;
		}
		return size_[i_root];
	}

	bool resize(size_t size) {
		size_t size_before = root_.size();

		if (size_before >= size) {
			return false;
		}
		root_.resize(size);
		rank_.resize(size, 0);
		size_.resize(size, 1);
		for (size_t i = size_before; i < size; ++i) {
			root_[i] = i;
		}
		return true;
	}

	size_t size() const {
		return root_.size();
	}

	vector<int> root_;
	vector<int> rank_;
	vector<int> size_;
};
endsnippet

snippet clsvec2 "2D Vector class"
class Vec2
{
public:
	using T = double;

public:
	T x;
	T y;

public:
	inline Vec2& operator= (const Vec2& rhs)
	{
		x = rhs.x;
		y = rhs.y;
		return *this;
	}

public:
	inline bool operator==(const Vec2& rhs) const
	{
		return ((x == rhs.x) && (y == rhs.y));
	}

	inline bool operator!=(const Vec2& rhs) const
	{
		return !(operator==(rhs));
	}

	inline Vec2 operator+ (const Vec2& rhs) const
	{
		return Vec2(x + rhs.x, y + rhs.y);
	}

	inline Vec2 operator- (const Vec2& rhs) const
	{
		return Vec2(x - rhs.x, y - rhs.y);
	}

	inline Vec2 operator* (T rhs) const
	{
		return Vec2(T(x * rhs), T(y * rhs));
	}

	inline Vec2 operator/ (T rhs) const
	{
		return Vec2(T(x / rhs), T(y / rhs));
	}

	inline Vec2 operator- () const
	{
		return Vec2(-x, -y);
	}

	inline Vec2& operator+= (const Vec2& rhs)
	{
		x += rhs.x;
		y += rhs.y;
		return *this;
	}

	inline Vec2& operator-= (const Vec2& rhs)
	{
		x -= rhs.x;
		y -= rhs.y;
		return *this;
	}

	inline Vec2& operator*= (T rhs)
	{
		x = T(x * rhs);
		y = T(y * rhs);
		return *this;
	}

	inline Vec2& operator/= (T rhs)
	{
		x = T(x / rhs);
		y = T(y / rhs);
		return *this;
	}

public:
	inline double norm() const
	{
		return sqrt(squaredNorm());
	}

	inline T squaredNorm() const
	{
		return ((x * x) + (y * y));
	}

	inline double length() const 
	{
		return norm();
	}

	inline double length(const Vec2& pos) const
	{
		return sqrt(squaredLength(pos));
	}

	inline T squaredLength() const 
	{
		return squaredNorm();
	}

	inline T squaredLength(const Vec2& pos) const
	{
		return (((x - pos.x) * (x - pos.x)) + ((y - pos.y) * (y - pos.y)));
	}
	
	inline T l1length() const {
		return abs(x) + abs(y);
	}

	inline T l1length(const Vec2& pos) const {
		return abs(x - pos.x) + abs(y - pos.x);
	}

	inline void normalize()
	{
		double l = norm();
		if (l < numeric_limits<double>::epsilon()) {
			x = 0;
			y = 0;
		}
		else {
			x = (T)(x / l);
			y = (T)(y / l);
		}
	}

	inline Vec2 normalized() const
	{
		Vec2 n(*this);
		n.normalize();
		return n;
	}

	inline T dot(const Vec2& rhs) const
	{
		return x * rhs.x + y * rhs.y;
	}

	inline T cross(const Vec2& rhs) const
	{
		return x * rhs.y - y * rhs.x;
	}

	inline double angle(const Vec2& rhs) const
	{
		double sqlen = squaredLength();
		double sqlen2 = rhs.squaredLength();

		if (sqlen == 0.0 || sqlen2 == 0.0) {
			return 0.0;
		}

		double val = dot(rhs) / sqrt(sqlen) / sqrt(sqlen2);
		val = std::max(-1.0, min(val, 1.0));
		return acos(val);
	}

public:
	static const Vec2& xAxis() { static Vec2 vec(1, 0); return vec; }
	static const Vec2& yAxis() { static Vec2 vec(0, 1); return vec; }
	static const Vec2& zero() { static Vec2 vec(0, 0); return vec; }
	friend ostream& operator<< (ostream& ostr, const Vec2& rhs) {
		ostr << setprecision(15) << rhs.x << " " << rhs.y;
		return ostr;
	}

	friend istream& operator>> (istream& istr, Vec2& rhs) {
		istr >> rhs.x >> rhs.y;
		return istr;
	}

	friend bool operator< (const Vec2& lhs, const Vec2& rhs) {
		return lhs.x != rhs.x ? lhs.x < rhs.x : lhs.y < rhs.y;
	}

public:
	Vec2() : x(T(0)), y(T(0)) {}

	Vec2(T x_, T y_) : x(x_), y(y_) {}

	Vec2(const Vec2& rhs) : x(rhs.x), y(rhs.y) {}

	~Vec2() {}

public:
	// To find orientation of ordered triplet (p, q, r). 
	// The function returns following values 
	// 0 --> p, q and r are colinear 
	// +1 --> Clockwise 
	// -1 --> Counterclockwise 
	static int orientation(const Vec2& p, const Vec2& q, const Vec2& r)
	{
		// https://www.geeksforgeeks.org/orientation-3-ordered-points/
		T val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
		if (val == 0) {
			return 0;
		}
		return val > 0 ? 1 : -1;
	}

	// Given three colinear points p, q, r, the function checks if 
	// point q lies on line segment 'pr' 
	static bool onSegment(const Vec2 p, const Vec2 q, const Vec2 r)
	{
		return q.x <= max(p.x, r.x) 
			&& q.x >= min(p.x, r.x) 
			&& q.y <= max(p.y, r.y) 
			&& q.y >= min(p.y, r.y);
	}
};
endsnippet

snippet clsseg2 "2D Segment class"
class Seg2
{
public:
	Vec2 start;
	Vec2 end;

public:
	Vec2 center() const { return (start + end) / 2;}

	Vec2 direction() const { return end - start; }

	Vec2 normalizedDirection() const { return direction().normalized(); }

	double length() const { return (end - start).length(); }

public:
	bool contains(const Vec2& point) const {
		static constexpr double epsilon = 1e-10;
		return Vec2::onSegment(start, point, end) && 
			(start - point).cross(point - end) < epsilon;
	}

	bool contains(const Seg2& rhs) const {
		return contains(rhs.start) && contains(rhs.end);
	}

	bool intersects(const Seg2& rhs) const {
		const auto& p1 = this->start;
		const auto& q1 = this->end;
		const auto& p2 = rhs.start;
		const auto& q2 = rhs.end;

		int o1 = Vec2::orientation(p1, q1, p2); 
		int o2 = Vec2::orientation(p1, q1, q2); 
		int o3 = Vec2::orientation(p2, q2, p1); 
		int o4 = Vec2::orientation(p2, q2, q1); 

		if (o1 * o2 < 0 && o3 * o4 < 0) 
			return true; 

		if (o1 == 0 && Vec2::onSegment(p1, p2, q1)) return true; 
		if (o2 == 0 && Vec2::onSegment(p1, q2, q1)) return true; 
		if (o3 == 0 && Vec2::onSegment(p2, p1, q2)) return true; 
		if (o4 == 0 && Vec2::onSegment(p2, q1, q2)) return true; 
		return false;
	}

	bool colinear(const Seg2& rhs) const {
		// https://stackoverflow.com/a/565282
		const auto& p = this->start;
		const auto r = this->end - this->start;
		const auto& q = rhs.start;
		const auto s = rhs.end - rhs.start;

		auto a = r.cross(s);
		auto b = (q - p).cross(r);
		return a == 0 && b == 0;
	}
	
	Vec2 intersection(const Seg2& rhs) const {
		// https://stackoverflow.com/a/565282
		const auto& p = this->start;
		const auto r = this->end - this->start;
		const auto& q = rhs.start;
		const auto s = rhs.end - rhs.start;

		auto a = r.cross(s);
		auto b = (q - p).cross(r);
		if (a == 0 && b == 0) {
			// case1: colinear
			if (this->contains(rhs.start)) {
				return rhs.start;
			}
			else {
				return rhs.end;
			}
		} else if (a == 0 && b != 0) {
			// case2: parallel
			throw runtime_error("case 2. should be checked using intersects() before");
		}
		double t = (q - p).cross(s) / a;
		double u = (q - p).cross(r) / a;
		if (0 <= t && t <= 1.0 && 0 <= u && u <= 1.0) {
			// case3: intersects
			return p + r * t;
		}
		else {
			// case 4: not parallel but do not intersects
			throw runtime_error("case 4. should be checked using intersects() before");
		}
	}

public:
	friend ostream& operator<< (ostream& ostr, const Seg2& rhs) {
		ostr << "Seg2(" << rhs.start << ", " << rhs.end << ")";
		return ostr;
	}

	friend istream& operator>> (istream& istr, Seg2& rhs) {
		istr >> rhs.start >> rhs.end;
		return istr;
	}
	

public:
	Seg2() {};

	Seg2(const Vec2& start, const Vec2& end) 
		: start(start), end(end) {};

	Seg2(Vec2::T startX, Vec2::T startY, Vec2::T endX, Vec2::T endY) 
		: start{startX, startY}, end{endX, endY} {};

	Seg2(const Seg2& rhs) 
		: start(rhs.start), end(rhs.end) {};

public:
	~Seg2() {}
};
endsnippet

snippet clscircle "2D Circle class"
class Circle
{
	using T = Vec2::T;
	
	Vec2 center;
	T radius;
public:
	inline bool operator==(const Circle& rhs) const {
		return ((center == rhs.center) && (radius == rhs.radius));
	}

public:
	double area() const { return radius * radius * M_PI; }

public:
	bool contains(const Vec2& rhs) const {
		Vec2 d = rhs - center;
		return rhs.squaredLength(center) <= radius * radius;
	}

	bool contains(const Circle& rhs) const {
		return radius >= (center.length(rhs.center) + rhs.radius);
	}

	bool overlaps(const Circle& rhs) const {
		double d = center.length(rhs.center);
		return d < radius + rhs.radius;
		//return abs(radius - rhs.radius) < d && d < radius + rhs.radius;
	}

	optional<pair<Vec2, Vec2>> intersection(const Circle& rhs) const {
		// http://paulbourke.net/geometry/circlesphere/
		if (*this == rhs) {
			return nullopt;
		}
		const Vec2& p0 = this->center;
		const Vec2& p1 = rhs.center;
		double r0 = this->radius;
		double r1 = rhs.radius;
		double d = p0.length(p1);

		if (d >= r0 + r1) {
			return nullopt;
		}
		if (d <= abs(r0 - r1)) {
			return nullopt;
		}

		double a = (r0*r0 - r1*r1 + d*d) / (2 * d);
		double h = sqrt(r0*r0 - a*a);
		Vec2 p2 = p0 + (p1 - p0) * (a / d);
		Vec2 diff = Vec2{p1.y-p0.y, p1.x-p0.x} * h / d;
		return make_pair(p2 + diff, p2 - diff);
	}

	double overlappingArea(const Circle& rhs) const {
		if (!overlaps(rhs)) {
			return 0;
		}
		if (rhs.contains(*this)) {
			return area();
		}
		if (this->contains(rhs)) {
			return rhs.area();
		}
		const double& r0 = radius;
		const double& r1 = rhs.radius;
		const double d = center.length(rhs.center);
		const double angle0 = acos((r0 * r0 + d * d - r1 * r1) / (2 * r0 * d));
		const double angle1 = acos((r1 * r1 + d * d - r0 * r0) / (2 * r1 * d));
		const double rr0 = radius * radius;
		const double rr1 = rhs.radius * rhs.radius;

		double ans = 
			+ rr0 * angle0 - rr0 * sin(2*angle0) * 0.5
			+ rr1 * angle1 - rr1 * sin(2*angle1) * 0.5;
		return ans;
	}

public:
	friend istream& operator>> (istream& istr, Circle& rhs) {
		istr >> rhs.center.x >> rhs.center.y >> rhs.radius;
		return istr;
	}

public:
	Circle() : center(0, 0), radius(T(0)) {}

	Circle(T x, T y, T r) : center(x, y), radius(r) {}

	Circle(const Circle& rhs) : center(rhs.center), radius(rhs.radius) {}

	~Circle() {}
};
endsnippet

snippet clssquare "2D Square class"
class Square
{
	using T = Vec2::T;
	
	T left;
	T right;
	T bottom;
	T top;
public:
	inline bool operator==(const Square& rhs) const {
		return (top == rhs.top && bottom == rhs.bottom && left == rhs.left && right == rhs.right);
	}

public:
	T area() const { return (top - bottom) * (right - left); }

public:
	bool contains(const Vec2& rhs) const {
		return left <= rhs.x && rhs.x <= right && bottom <= rhs.y && rhs.y <= top;
	}

public:
	friend istream& operator>> (istream& istr, Square& rhs) {
		istr >> rhs.left >> rhs.right >> rhs.bottom >> rhs.top;
		return istr;
	}

public:
	Square() : left(0), right(1), bottom(0), top(1) {}

	Square(T l, T r, T b, T t) : left(l), right(r), bottom(b), top(t) {}

	~Square() {}
};
endsnippet


snippet algconvexhull "convex hull algorithm"
vector<Vec2> convexHull(vector<Vec2> points) {
	// https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain#C++
	size_t n = points.size();
	if (n <= 3) {
		return points;
	}

	vector<Vec2> H(2*n);
	size_t k = 0;

	sort(points.begin(), points.end());
	
	for (size_t i = 0; i < n; ++i) {
		while (k >= 2 && (H[k-1] - H[k-2]).cross(points[i] - H[k-2]) <= 0) k--;
		H[k++] = points[i];
	}
	
	// Build upper hull
	for (size_t i = n-1, t = k+1; i > 0; --i) {
		while (k >= t && (H[k-1] - H[k-2]).cross(points[i-1] - H[k-2]) <= 0) k--;
		H[k++] = points[i-1];
	}

	H.resize(k-1);
	return H;
}
endsnippet

snippet algrotatingcalipers "rotating calipers"
void rotatingCalipers(const vector<Vec2>& shell, int& i, int& j) {
	// rotating calipers algorithm
	i = 0;
	j = 1;
	const int m = shell.size();

	LL furthest = shell[j].squaredLength(shell[i]);
	int iBest=i, jBest=j;
	
	for (int k = 0; k < shell.size() || i != 0; ++k) {
		const int i2 = (i + 1) % m;
		const int j2 = (j + 1) % m;
		int orientation =
				Vec2::orientation(shell[i], shell[i2], shell[j2] - shell[j] + shell[i]);
		if (orientation > 0) {
			i = i2;
		} else {
			j = j2;
		}
		LL distance = shell[j].squaredLength(shell[i]);
		if (distance > furthest) {
			furthest = distance;
			iBest = i;
			jBest = j;
		}
	}
	i = iBest;
	j = jBest;
}
endsnippet

snippet algshoelace "the shoelace algorithm, that calculates area of the 2d polygon"
double shoelace(const vector<Point2>& points) {
	double res = 0;
	for (int i = 0; i <= points.size(); ++i) {
		res += points[i].x * points[(i+1) % points.size()].y;
		res -= points[i].y * points[(i+1) % points.size()].x;
	}
	return 0.5 * abs(res);
}
endsnippet

snippet algbuildtree "Build tree from a undirected graph and a root index"
vector<vector<int>> buildTree(const vector<vector<int>>& edges, int root) {
	int N = edges.size();
	vector<vector<int>> tree(N);
	vector<int> visited(N, false);
	vector<int> st;
	st.push_back(root);
	while (!st.empty()) {
		int u = st.back(); st.pop_back();
		if (visited[u]) {
			continue;
		}
		visited[u] = true;
		for (int v : edges[u]) {
			if (visited[v]) {
				continue;
			}
			tree[u].push_back(v);
			st.push_back(v);
		}
	}
	return tree;
}
endsnippet


snippet clssegtree "Segment tree class, solution of boj_2042"
template<typename T>
class SegTree {
 private:
	vector<T> tree_;
	size_t n_;

 public:
	template <typename U>
	SegTree(const size_t size, const U& default_value)
			: SegTree(vector<U>(size, default_value)) {}

	template <typename U>
	SegTree(const vector<U>& data) {
		n_ = data.size();
		tree_.resize(4 * n_);
		std::fill(tree_.begin(), tree_.end(), falseValue());
		init(data, 0, n_ - 1, 1);
	}

	T query(size_t left, size_t right) {
		return query(left, right, 1, 0, n_ - 1);
	}

	template <typename U>
	T update(size_t idx, const U& new_value) {
		return update(idx, new_value, 1, 0, n_ - 1);
	}

 private:
	template <typename U>
	T init(const vector<U>& data, size_t left, size_t right, size_t node_idx) {
		if (left == right) {
			return tree_[node_idx] = transform(data[left]);
		}
		size_t mid = (left + right) / 2;
		T res_left = init(data, left, mid, node_idx * 2);
		T res_right = init(data, mid + 1, right, node_idx * 2 + 1);
		return tree_[node_idx] = aggregate(res_left, res_right);
	}

	T query(size_t left,
					size_t right,
					size_t node_idx,
					size_t node_left,
					size_t node_right) {
		if (right < node_left || node_right < left) {
			return falseValue();
		}
		if (left <= node_left && node_right <= right) {
			return tree_[node_idx];
		}
		size_t mid = (node_left + node_right) / 2;
		T res_left = query(left, right, node_idx * 2, node_left, mid);
		T res_right = query(left, right, node_idx * 2 + 1, mid + 1, node_right);
		return aggregate(res_left, res_right);
	}

	template <typename U>
	T update(size_t idx,
					 const U& new_value,
					 size_t node_idx,
					 size_t node_left,
					 size_t node_right) {
		if (idx < node_left || node_right < idx) {
			return tree_[node_idx];
		}
		if (node_left == node_right) {
			return tree_[node_idx] = transform(new_value);
		}
		size_t mid = (node_left + node_right) / 2;
		T res_left = update(idx, new_value, node_idx * 2, node_left, mid);
		T res_right = update(idx, new_value, node_idx * 2 + 1, mid + 1, node_right);
		return tree_[node_idx] = aggregate(res_left, res_right);
	}

	template <typename U>
	static T transform(const U& v) {
		return v;
	}

	static T aggregate(const T& lhs, const T& rhs) { return lhs + rhs; }

	static T falseValue() { return 0; }
};
endsnippet

snippet clsfenwicktree "binary indexed tree class, solution of boj_2042"
template <typename T>
class FenwickTree {
 public:
	vector<T> arr_;
	vector<T> tree_;

 public:
	FenwickTree(size_t n) 
		: arr_(n, defaultValue()) 
		, tree_(n, defaultValue()) 
	{}

	FenwickTree(const vector<T>& arr) {
		init(arr);
	}

 public:
	void update(int i, const T& val) {
		T diff = val - arr_[i];
		arr_[i] = val;
		while (i < tree_.size()) {
			tree_[i] += diff;
			i += LSB(i);
		}
	}

	T query(int i) {
		T res = defaultValue();
		while (i > 0) {
			res += tree_[i];
			i -= LSB(i);
		}
		return res;
	}

	T query(int i, int j) {
		T res = defaultValue();
		for (i--; j > i; j -= LSB(j)) {
			res += tree_[j];
		}
		for (; i > j; i -= LSB(i)) {
			res -= tree_[i];
		}
		return res;
	}

	static inline T defaultValue() {
		return 0;
	}

	static inline int LSB(int i) { return i & (-i); }

 private:
	void init(const vector<T>& arr) {
		arr_ = arr;
		tree_ = arr;
		for (int i = 1; i < tree_.size(); ++i) {
			int j = i + LSB(i);
			if (j < tree_.size())
				tree_[j] += tree_[i];
		}
	}
};
endsnippet

snippet algkmp "KMP, string search algorithm. solution of boj_5525"
vector<size_t> kmpPartialMatch(const string& query){
		size_t m = query.size();
		vector<size_t> pi(m, 0);

		size_t begin = 1, matched = 0;
		
		while(begin + matched < m){
				if(query[begin + matched] == query[matched]){
						matched++;
						pi[begin + matched - 1] = matched;
				}
				else{
						if(matched == 0)
								begin++;
						else{
								begin += matched - pi[matched - 1];
								matched = pi[matched - 1];
						}
				}
		}
		return pi;
}

vector<size_t> kmp(const string& source, const string& query) {
	size_t n = source.size();
	size_t m = query.size();

	vector<size_t> res;
	vector<size_t> pi = kmpPartialMatch(query);

	size_t matched = 0;
	for (int i = 0; i < n; i++)
	{
		while (matched > 0 && source[i] != query[matched]) {
			matched = pi[matched - 1];
		}
		if (source[i] == query[matched])
		{
			matched++;
			if (matched == m)
			{
				res.push_back(i - m + 1);
				matched = pi[matched - 1];
			}
		}
	}

	return res;
}
endsnippet

snippet algtoposort "topological sort. the solution of boj_2252"
vector<int> topologicalSort(const vector<vector<int>>& graph) {
	size_t N = graph.size();
	vector<int> incomming(N, 0);
	for (int u = 0; u < graph.size(); ++u) {
		for (int v : graph[u]) {
			incomming[v]++;
		}
	}

	queue<int> Q;
	for (int v = 0; v < N; ++v) {
		if (incomming[v] == 0) {
			Q.push(v);
		}
	}

	vector<int> res;
	while (!Q.empty()) {
		int u = Q.front(); Q.pop();
		res.push_back(u);
		for (int v : graph[u]) {
			incomming[v]--;
			if (incomming[v] == 0) {
				Q.push(v);
			}
		}
	}
	return res;
}
endsnippet

snippet clssparsetable "Sparse table, datastructure. the solution of boj_17435"
class SparseTable {
 public:
	vector<vector<int>> table_;
	int maxDepth_;

 public:
	SparseTable(const vector<int>& f, int maxDepth = 20)
			: table_(maxDepth), maxDepth_(maxDepth) {
		table_[0] = f;
		for (int i = 1; i < maxDepth; ++i) {
			const vector<int>& prev = table_[i - 1];
			vector<int>& row = table_[i];
			row.resize(prev.size());
			for (int j = 0; j < row.size(); ++j) {
				row[j] = prev[prev[j]];
			}
		}
	}

	int query(int n, int x) const {
		for (int i = 0; i < maxDepth_; ++i) {
			if ((n >> i) & 1) {
				x = table_[i][x];
			}
		}
		return x;
	}
};
endsnippet

snippet alglca "lowest common ancestor algorithm, solution of boj_11438"
class SparseTable {
	vector<vector<int>> table_;
	int maxDepth_;

 public:
	SparseTable(const vector<int>& f, int maxDepth = 20)
			: table_(maxDepth), maxDepth_(maxDepth) {
		table_[0] = f;
		for (int i = 1; i < maxDepth; ++i) {
			const vector<int>& prev = table_[i - 1];
			vector<int>& row = table_[i];
			row.resize(prev.size());
			for (int j = 0; j < row.size(); ++j) {
				row[j] = prev[prev[j]];
			}
		}
	}

	SparseTable() {}

	int query(int n, int x) const {
		for (int i = 0; i < maxDepth_; ++i) {
			if ((n >> i) & 1) {
				x = table_[i][x];
			}
		}
		return x;
	}
};

class LCA {
	vector<int> depth_;
	int logMaxDepth_;
	SparseTable parent_;
 public:
	LCA(const vector<int>& parent, const vector<int>& depth) : depth_(depth) {
		int maxDepth = 1;
		for (auto d : depth) {
			maxDepth = max(d, maxDepth);
		}
		logMaxDepth_ = log2(maxDepth) + 1;
		parent_ = SparseTable(parent, logMaxDepth_);
	}

	int query(int u, int v) {
		if (depth_[u] < depth_[v]) {
			swap(u, v);
		}

		if (depth_[u] != depth_[v]) {
			u = parent_.query(depth_[u] - depth_[v], u);
		}

		for (int i = logMaxDepth_; i >= 0; --i) {
			int u2 = parent_.query(1<<i, u);
			int v2 = parent_.query(1<<i, v);
			if (u2 != v2 && u2 != 0) {
				u = u2;
				v = v2;
			}
		}
		if (u != v) {
			u = parent_.query(1, u);
			v = parent_.query(1, v);
		}
		return u;
	}
};
endsnippet

snippet clscountingsegtree "Counting Segment tree, solution of boj_7626"
template<typename T>
class CountingSegTree {
 public:
	vector<T> tree_;
	size_t n_;

	vector<int> count_;

 public:
	CountingSegTree(size_t size) {
		n_ = size;
		tree_.resize(4 * n_, 0);
		count_.resize(4 * n_, 0);
	}

	T query(size_t left, size_t right) {
		return query(left, right, 1, 0, n_ - 1);
	}

	void updateRange(size_t left, size_t right, int inc, 
			const function<T(int, size_t, size_t)>& transform) {
		updateRange(left, right, inc, 1, 0, n_ - 1, transform);
	}

 private:
	T query(size_t left,
					size_t right,
					size_t node_idx,
					size_t node_left,
					size_t node_right) {
		if (right < node_left || node_right < left) {
			return 0;
		}
		if (left <= node_left && node_right <= right) {
			return tree_[node_idx];
		}
		size_t mid = (node_left + node_right) / 2;
		T res_left = query(left, right, node_idx * 2, node_left, mid);
		T res_right = query(left, right, node_idx * 2 + 1, mid + 1, node_right);
		return aggregate(res_left, res_right);
	}

	void updateRange(
			size_t left, 
			size_t right,
			const int& inc,
			size_t node_idx,
			size_t node_left,
			size_t node_right, 
			const function<T(int, size_t, size_t)>& transform) {
		if (right < node_left || node_right < left) {
			return;
		}
		if (left <= node_left && node_right <= right) {
			count_[node_idx] += inc;
		}
		else {
			size_t mid = (node_left + node_right) / 2;
			updateRange(left, right, inc, node_idx * 2, node_left, mid, transform);
			updateRange(left, right, inc, node_idx * 2 + 1, mid+1, node_right, transform);
		}

		if (count_[node_idx]) {
			tree_[node_idx] = transform(0, node_left, node_right);
		}
		else if (node_left == node_right) {
			tree_[node_idx] = 0;
		}
		else {
			tree_[node_idx] = aggregate(tree_[node_idx * 2], tree_[node_idx * 2 + 1]);
		}
	}

	static T aggregate(const T& lhs, const T& rhs) { return lhs + rhs; }
};
endsnippet

snippet algmergesort "merge sort algorithm. solution of boj_1517"
template <typename T>
LL merge_(typename vector<T>::iterator lLeft,
					 typename vector<T>::iterator lRight,
					 typename vector<T>::iterator rLeft,
					 typename vector<T>::iterator rRight) {
	vector<T> tmp;
	tmp.reserve(rRight - lLeft);
	auto begin = lLeft;

	LL countInv = 0;
	while (lLeft != lRight || rLeft != rRight) {
		if (lLeft == lRight) {
			tmp.push_back(*rLeft);
			rLeft++;
		} else if (rLeft == rRight || *lLeft <= *rLeft) {
			tmp.push_back(*lLeft);
			lLeft++;
		} else {
			countInv += lRight - lLeft;
			tmp.push_back(*rLeft);
			rLeft++;
		}
	}
	copy(tmp.begin(), tmp.end(), begin);
	return countInv;
}

template <typename T>
LL mergeSort(typename vector<T>::iterator left, typename vector<T>::iterator right) {
	if (left + 1 == right) {
		return 0;
	}
	LL countInv = 0;
	auto mid = left + (right - left) / 2;
	countInv += mergeSort<T>(left, mid);
	countInv += mergeSort<T>(mid, right);
	countInv += merge_<T>(left, mid, mid, right);
	return countInv;
}
endsnippet

snippet algtarjanscc "tarjan's algorithm, find strongly connected components. solution of boj_2150"
vector<vector<int>> tarjanSCC(const vector<vector<int>>& edges) {
	struct Vertex {
		int vid;
		int index = -1;
		bool processed = false;
	};
	vector<vector<int>> res;
	stack<Vertex*> S;
	vector<Vertex> vertices(edges.size());
	for (int i = 0; i < edges.size(); ++i) {
		vertices[i].vid = i;
	}
	int index = 0;

	function<int(Vertex&)> dfs = [&](Vertex& v) -> int {
		v.index = index++;
		S.push(&v);
		int parent = v.index;
		for (int nxt : edges[v.vid]) {
			Vertex& w = vertices[nxt];
			if (w.index == -1) {
				parent = min(parent, dfs(w));
			} else if (!w.processed) {
				parent = min(parent, w.index);
			}
		}
		if (parent == v.index) {
			vector<int> newSCC;
			Vertex* w;
			do {
				w = S.top();
				S.pop();
				w->processed = true;
				newSCC.push_back(w->vid);
			} while (w->vid != v.vid);
			res.push_back(newSCC);
		}
		return parent;
	};

	for (auto& v : vertices) {
		if (v.index == -1) {
			dfs(v);
		}
	}

	return res;
}
endsnippet

snippet alg2sat "2sat solver. solution of boj_11281"
vector<bool> twoSAT(const vector<vector<int>>& graph,
										const function<int(int)>& neg) {
	auto sccs = tarjanSCC(graph);
	size_t N = graph.size() / 2;

	vector<int> sccGroup(graph.size());
	for (int i = 0; i < sccs.size(); ++i) {
		const auto& scc = sccs[i];
		for (int j : scc) {
			sccGroup[j] = i;
		}
	}

	for (int i = 0; i < N; ++i) {
		if (sccGroup[i] == sccGroup[neg(i)]) {
			return {};
		}
	}

	vector<bool> res(N);
	for (int i = 0; i < res.size(); ++i) {
		res[i] = sccGroup[i] < sccGroup[neg(i)];
	}
	return res;
}
endsnippet

snippet algbipartite "bipartite matching algorithm. solution of boj_11375"
class BipartiteMatching {
 public:
	const vector<vector<int>>& edges_;
	size_t nDst_;
	vector<int> matches_;
	vector<bool> visited_;

 public:
	BipartiteMatching(const vector<vector<int>>& edges, int nDst = -1)
			: edges_(edges), nDst_(nDst) {
		if (nDst_ == -1) {
			for (int i = 0; i < edges.size(); ++i) {
				for (int w : edges[i]) {
					nDst_ = max(nDst_, (size_t)(w+1));
				}
			}
		}
		matches_.resize(nDst, -1);
		visited_.resize(nDst, false);
	}

	size_t solve() {
		size_t res = 0;
		for (size_t i = 0; i < edges_.size(); ++i) {
			fill(all(visited_), false);
			res += dfs(i);
		}
		return res;
	}

	std::vector<std::pair<int, int>> matches() const {
		std::vector<std::pair<int, int>> res;
		for (size_t dst = 0; dst < matches_.size(); ++dst) {
			const auto& src = matches_[dst];
			if (src != -1) {
				res.push_back({src, dst});
			}
		}
		return res;
	}

 private:
	bool dfs(int src) {
		for (int dst : edges_[src]) {
			if (visited_[dst]) {
				continue;
			}
			visited_[dst] = true;
			if (matches_[dst] == -1 || dfs(matches_[dst])) {
				matches_[dst] = src;
				return true;
			}
		}
		return false;
	}
};
endsnippet


snippet clsmatrix "2d matrix class"
template<unsigned R, unsigned C, typename T=LL>
class Matrix {
 public:
	T arr[R*C] = {0};
	
 public:
	Matrix() {}

	Matrix(const Matrix& other) {
		copy(other.arr, other.arr + (R*C), arr);
		if constexpr (MOD > 1) {
			for (size_t i = 0; i < R * C; ++i) {
				arr[i] %= MOD;
			}
		}
	}
	
	Matrix(const vector<T>&& rhs) {
		copy(rhs.begin(), rhs.end(), arr);
		if constexpr (MOD > 1) {
			for (size_t i = 0; i < R * C; ++i) {
				arr[i] %= MOD;
			}
		}
	}

 public:
	T& at(int r, int c) {
		r = r < 0 ? R + r : r;
		c = c < 0 ? C - c : c;
		return arr[C * r + c];
	}

	const T& constAt(int r, int c) const {
		r = r < 0 ? R + r : r;
		c = c < 0 ? C - c : c;
		return arr[C * r + c];
	}

	Matrix operator*=(const Matrix& rhs) {
		Matrix tmp = *this * rhs;
		copy(tmp.arr, tmp.arr + (R*C), arr);
		return *this;
	}

 public:
	friend std::ostream& operator<< (std::ostream& ostr, const Matrix& rhs) {
		for (size_t r = 0; r < R; ++r) {
			for (size_t c = 0; c < C; ++c) {
				ostr << rhs.constAt(r, c) << ((c == C-1) ? "\n" : " ");
			}
		}
		return ostr;
	}

	static constexpr Matrix eye() {
		static_assert(R == C);
		Matrix res;
		for (size_t i = 0; i < R; ++i) {
			res.at(i, i) = 1;
		}
		return res;
	}

	static constexpr Matrix zeros() {
		Matrix res;
		return res;
	}
};

template <unsigned R1,
					unsigned C1,
					typename T1,
					unsigned R2,
					unsigned C2,
					typename T2>
static Matrix<R1, C2, T1> operator*(const Matrix<R1, C1, T1>& lhs,
																		const Matrix<R2, C2, T2>& rhs) {
	static_assert(C1 == R2);
	static_assert(std::is_same<T1, T2>());
	Matrix<R1, C2, T1> res;
	for (size_t r = 0; r < R1; ++r) {
		for (size_t c = 0; c < C2; ++c) {
			for (size_t i = 0; i < C1; ++i) {
				res.at(r, c) += lhs.constAt(r, i) * rhs.constAt(i, c);
				if constexpr (MOD > 1) {
					if (res.at(r, c) < 0) res.at(r, c) += MOD;
					res.at(r, c) %= MOD;
				}
			}
		}
	}
	return res;
}
endsnippet

snippet algmatpow "power of matrix"
template <unsigned N, typename T>
Matrix<N, N, T> pow(const Matrix<N, N, T>& base, LL exp) {
	if (exp == -1) {
		return Matrix<N, N, T>::zeros();
	}
	if (exp == 0) {
		return Matrix<N, N, T>::eye();
	}
	if (exp == 1) {
		return base;
	}
	
	auto res = pow(base, exp / 2);
	res = res * res;
	if (exp & 1) {
		res *= base;
	}
	return res;
}
endsnippet
