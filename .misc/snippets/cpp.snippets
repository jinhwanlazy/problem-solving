snippet main "The main function"
#include <bits/stdc++.h> 
using namespace std;

int main()
{
	$0
	return 0;
}
endsnippet

snippet readi "read an integer"
int ${1:N};
scanf("%d", &$1);
$0
endsnippet

snippet readii "read two integers"
int ${1:N}, ${2:M};
scanf("%d %d", &$1, &$2);
$0
endsnippet

snippet readiii "read three integers"
int ${1:A}, ${2:B}, ${3:C};
scanf("%d %d %d", &$1, &$2, &$3);
$0
endsnippet

snippet readv "read a vector"
vector<${1:int}> ${2:xs}(${3:N});
for (int i = 0; i < $3; ++i) {
	scanf("%d", &$2[i]);
}
$0
endsnippet

snippet readvv "read a vector of vector"
vector<vector<${1:int}>> ${2:grid}(${3:N}, vector<$1>(${4:M}));
for (int i = 0; i < $3; ++i) {
	for (int j = 0; j < $4; ++j) {
		scanf("%d", &$2[i][j]);
	}
}
$0
endsnippet

snippet reads "read a string"
string ${1:S};
scanf("%s\n", &$1);
$0
endsnippet


snippet printi "print an integer"
printf("%d\n", $1);
$0
endsnippet

snippet printii "print two integers"
printf("%d %d\n", $1, $2);
$0
endsnippet

snippet printv "print a vector"
for (int i = 0; i < $1.size(); ++i) {
	printf("%d ", $1[i]);
}
printf("\n");
$0
endsnippet

snippet printvv "print a 2d vector"
for (int i = 0; i < $1.size(); ++i) {
	for(int j = 0; j < $1[i].size(); ++j) {
		printf("%d ", $1[i][j]);
	}
	printf("\n");
}
$0
endsnippet

snippet inf "pseudo infinity"
constexpr static ${1:int} INF = numeric_limits<${1}>::max();
$0
endsnippet

snippet dirs "4 directions in grid"
constexpr static int di[4] = {0, 0, -1, +1};
constexpr static int dj[4] = {-1, +1, 0, 0};
$0
endsnippet

snippet boundcheck "check if value is within bound"
inline bool boundCheck(int i, int max_i) {
	return 0 <= i && i < max_i;
}

inline bool boundCheck(int i, int min_i, int max_i) {
	return min_i <= i && i < max_i;
}

endsnippet

snippet boundcheck2 "check if value is within bound"
inline bool boundCheck(int i, int max_i) {
	return 0 <= i && i < max_i;
}

inline bool boundCheck(int i, int min_i, int max_i) {
	return min_i <= i && i < max_i;
}

inline bool boundCheck2d(int i, int j, int max_i, int max_j) {
	return boundCheck(i, max_i) && boundCheck(j, max_j);
}

inline bool boundCheck2d(int i, int j, int min_i, int min_j, int max_i, int max_j) {
	return boundCheck(i, min_i, max_i) && boundCheck(j, min_j, max_j);
}
endsnippet

snippet boundcheck3 "check if value is within bound"
inline bool boundCheck(int i, int max_i) {
	return 0 <= i && i < max_i;
}

inline bool boundCheck(int i, int min_i, int max_i) {
	return min_i <= i && i < max_i;
}

inline bool boundCheck3d(int i, int j, int k, int max_i, int max_j, int max_k) {
	return boundCheck(i, max_i) && boundCheck(j, max_j) && boundCheck(k, max_k);
}

inline bool boundCheck3d(int i, int j, int k, int min_i, int min_j, int min_k, int max_i, int max_j, int max_k) {
	return boundCheck(i, min_i, max_i) && boundCheck(j, min_j, max_j) && boundCheck(k, min_k, max_k);
}
endsnippet

snippet stredge "basic edge struct"
struct Edge
{
	int u;
	int v;
	${1:int} w; /* cost */
}
endsnippet

snippet algdijkstra "dijkstra shortest path algorithm. solution of boj_13913"
using LL = long long;
constexpr static int INF = numeric_limits<int>::max();

struct State {
	int u;
	LL cost;

	friend bool operator<(const State& lhs, const State& rhs) {
		return lhs.cost > rhs.cost;
	}
};

struct Edge {
	int u;
	int v;
	LL cost;
};

vector<LL> dijkstra(const vector<vector<Edge>>& edges, int src, vector<int> *trace=nullptr) {
	vector<LL> cost(edges.size(), INF);
	if (trace) {
		trace->resize(edges.size());
		fill(trace->begin(), trace->end(), -1);
	}
	priority_queue<State> Q;
	cost[src] = 0;
	Q.push({src, 0});
	while (!Q.empty()) {
		auto [u, c] = Q.top(); Q.pop();
		if (cost[u] < c) {
			continue;
		}
		for (const auto& [_, v, w] : edges[u]) {
			int next_cost = c + w;
			if (next_cost < cost[v]) {
				cost[v] = next_cost;
				Q.push({v, next_cost});
				if (trace) {
					(*trace)[v] = u;
				}
			}
		}
	}
	return cost;
}
endsnippet

snippet algbellman "bellman-ford, shortest path algorithm. solution of boj_11657"
using LL = long long;
constexpr static LL INF = numeric_limits<LL>::max();

struct Edge {
	int u;
	int v;
	LL cost;
};

vector<LL> bellmanFord(const vector<Edge>& edges, int n_vertices, int src) {
	vector<LL> cost(n_vertices+1, INF);
	cost[src] = 0;

	for (int i = 1; i <= edges.size(); ++i) {
		for (const auto& [u, v, c] : edges) {
			if (cost[u] != INF && cost[v] > cost[u] + c) {
				cost[v] = cost[u] + c;
				if (i == edges.size()) {
					return {};
				}
			}
		}
	}
	return cost;
}

endsnippet


snippet algfloyd "floyd-warshall, shortest path algorithm. solution of boj_11404"
using LL = long long;
constexpr static LL INF = numeric_limits<int>::max();

vector<vector<LL>> floydWarshall(const vector<vector<LL>>& adj) {
	size_t N = adj.size()-1;
	auto cost = adj;

	for (int k = 1; k <= N; ++k) {
		for (int i = 1; i <= N; ++i) {
			for (int j = 1; j <= N; ++j) {
				if (cost[i][k] != INF && cost[k][j] != INF) {
					cost[i][j] = min(cost[i][k] + cost[k][j], cost[i][j]);
				}
			}
		}
	}
	return cost;
}
endsnippet

snippet algsieve "Sieve of Eratosthenes"
struct Sieve
{
	Sieve(size_t max_size) : data_(max_size, true) {
		data_[0] = false;
		data_[1] = false;
		for (size_t i = 2; i < max_size; ++i) {
			if (!data_[i]) {
				continue;
			}
			for (size_t j = i * 2; j < max_size; j += i) {
				data_[j] = false;
			}
		}
	}
	
	bool isPrime(size_t i) {
		return data_[i];
	}
	
	vector<bool> data_;
};
endsnippet

snippet alglcs "LCS, longest common subsequence algorithm. solution of boj_9252"
int LCS(const string& A, const string& B, string* trace=nullptr) 
{
	/*
	 * dp[i][j] := LCS(A[:i], B[:j])
	 */
	vector<vector<int>> dp(A.size()+1, vector<int>(B.size()+1, 0));
	for (int i = 1; i <= A.size(); ++i) {
		for (int j = 1; j <= B.size(); ++j) {
			if (A[i-1] == B[j-1]) {
				dp[i][j] = dp[i-1][j-1] + 1;
			}
			else {
				dp[i][j] = max(dp[i][j-1], dp[i-1][j]);
			}
		}
	}
	
	if (trace != nullptr) {
		int i = A.size();
		int j = B.size();
		trace->clear();
		while (i > 0 && j > 0) {
			if (A[i-1] == B[j-1]) {
				trace->push_back(A[i-1]);
				i--;
				j--;
			}
			else if (dp[i-1][j] == dp[i][j]) {
				i--;
			}
			else if (dp[i][j-1] == dp[i][j]) {
				j--;
			}
		}
		reverse(trace->begin(), trace->end());
	}
	return dp.back().back();
}
endsnippet

snippet algunionfind "Union Find Set data structure. solution of boj_4195"
struct UnionFindSet {
	UnionFindSet(int size) : root_(size), rank_(size, 0), size_(size, 1) {
		for (int i = 0; i < size; ++i) {
			root_[i] = i;
		}
	}

	int find(int i) {
		if (root_[i] == i) {
			return i;
		}
		int root = find(root_[i]);
		root_[i] = root;
		return root;
	}

	int merge(int i, int j) {
		int i_root = find(i);
		int j_root = find(j);
		if (i_root == j_root) {
			return size_[i_root];
		}
		if (rank_[i_root] < rank_[j_root]) {
			root_[i_root] = j_root;
			size_[j_root] += size_[i_root];
			size_[i_root] = 0;
			return size_[j_root];
		}
		root_[j_root] = i_root;
		size_[i_root] += size_[j_root];
		size_[j_root] = 0;
		if (rank_[i_root] == rank_[j_root]) {
			rank_[i_root]++;
		}
		return size_[i_root];
	}

	bool resize(size_t size) {
		size_t size_before = root_.size();

		if (size_before >= size) {
			return false;
		}
		root_.resize(size);
		rank_.resize(size, 0);
		size_.resize(size, 1);
		for (int i = size_before; i < size; ++i) {
			root_[i] = i;
		}
		return true;
	}

	size_t size() const {
		return root_.size();
	}

	vector<int> root_;
	vector<int> rank_;
	vector<int> size_;
};
endsnippet

snippet clspoint2 "2D point class"
class Point2
{
	using T = ${1:double};

public:
	T x;
	T y;

public:
	inline Point2& operator= (const Point2& rhs)
	{
		x = rhs.x;
		y = rhs.y;
		return *this;
	}

public:
	inline bool operator==(const Point2& rhs) const
	{
		return ((x == rhs.x) && (y == rhs.y));
	}

	inline bool operator!=(const Point2& rhs) const
	{
		return !(operator==(rhs));
	}

	inline Point2 operator+ (const Point2& rhs) const
	{
		return Point2(x + rhs.x, y + rhs.y);
	}

	inline Point2 operator- (const Point2& rhs) const
	{
		return Point2(x - rhs.x, y - rhs.y);
	}

	inline Point2 operator* (T rhs) const
	{
		return Point2(T(x * rhs), T(y * rhs));
	}

	inline Point2 operator/ (T rhs) const
	{
		return Point2(T(x / rhs), T(y / rhs));
	}

	inline Point2 operator- () const
	{
		return Point2(-x, -y);
	}

	inline Point2& operator+= (const Point2& rhs)
	{
		x += rhs.x;
		y += rhs.y;
		return *this;
	}

	inline Point2& operator-= (const Point2& rhs)
	{
		x -= rhs.x;
		y -= rhs.y;
		return *this;
	}

	inline Point2& operator*= (T rhs)
	{
		x = T(x * rhs);
		y = T(y * rhs);
		return *this;
	}

	inline Point2& operator/= (T rhs)
	{
		x = T(x / rhs);
		y = T(y / rhs);
		return *this;
	}

public:
	inline double norm() const
	{
		return sqrt(squaredNorm());
	}

	inline double squaredNorm() const
	{
		return ((x * x) + (y * y));
	}

	inline double length(const Point2& pos) const
	{
		return sqrt(squaredLength(pos));
	}

	inline double squaredLength(const Point2& pos) const
	{
		return (((x - pos.x) * (x - pos.x)) + ((y - pos.y) * (y - pos.y)));
	}

	inline void normalize()
	{
		double l = norm();
		if (l < numeric_limits<double>::epsilon()) {
			x = 0;
			y = 0;
		}
		else {
			x = (T)(x / l);
			y = (T)(y / l);
		}
	}

	inline Point2 normalized() const
	{
		Point2 n(*this);
		n.normalize();
		return n;
	}

	public:
	static const Point2& xAxis() { static Point2 vec(1, 0); return vec; }
	static const Point2& yAxis() { static Point2 vec(0, 1); return vec; }
	static const Point2& zero() { static Point2 vec(0, 0); return vec; }
	friend ostream& operator<< (ostream& ostr, const Point2& rhs) {
		ostr << "Point2[" << rhs.x << ", " << rhs.y << "]";
		return ostr;
	}

	friend istream& operator>> (istream& istr, Point2& rhs) {
		istr >> rhs.x >> rhs.y;
		return istr;
	}

	public:
	Point2() : x(T(0)), y(T(0)) {}

	Point2(T x_, T y_) : x(x_), y(y_) {}

	Point2(const Point2& rhs) : x(rhs.x), y(rhs.y) {}

	~Point2() {}
};

endsnippet

