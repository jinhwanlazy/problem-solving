snippet clssegtree "Segment tree class"
template <typename T, typename internal_t = T>
class SegTree {
 public:
	const function<internal_t()> defaultFn_;
	const function<internal_t(const T&)> transformFn_;
	const function<internal_t(const internal_t&, const internal_t&)> aggregateFn_;
	size_t n_;
	vector<internal_t> tree_;

	SegTree(const vector<T>& data,
					const function<internal_t()>&& defaultFn,
					const function<internal_t(const T&)>&& transformFn,
					const function<internal_t(const internal_t&, const internal_t&)>&& aggregateFn)
			: defaultFn_(defaultFn),
				transformFn_(transformFn),
				aggregateFn_(aggregateFn),
				n_(data.size()),
				tree_(4 * n_, defaultFn_()) {
		init(data, 0, n_ - 1, 1);
	}

	internal_t query(size_t left, size_t right) {
		return query(left, right, 1, 0, n_ - 1);
	}

	internal_t update(size_t idx, const T& newValue) {
		return update(idx, newValue, 1, 0, n_ - 1);
	}

 private:
	internal_t init(const vector<T>& data,
									size_t left,
									size_t right,
									size_t nodeIdx) {
		if (left == right) {
			return tree_[nodeIdx] = transformFn_(data[left]);
		}
		size_t mid = (left + right) / 2;
		internal_t res_left = init(data, left, mid, nodeIdx * 2);
		internal_t res_right = init(data, mid + 1, right, nodeIdx * 2 + 1);
		return tree_[nodeIdx] = aggregateFn_(res_left, res_right);
	}

	internal_t query(size_t left,
									 size_t right,
									 size_t nodeIdx,
									 size_t nodeLeft,
									 size_t nodeRight) {
		if (right < nodeLeft || nodeRight < left) {
			return defaultFn_();
		}
		if (left <= nodeLeft && nodeRight <= right) {
			return tree_[nodeIdx];
		}
		size_t mid = (nodeLeft + nodeRight) / 2;
		internal_t res_left = query(left, right, nodeIdx * 2, nodeLeft, mid);
		internal_t res_right =
				query(left, right, nodeIdx * 2 + 1, mid + 1, nodeRight);
		return aggregateFn_(res_left, res_right);
	}

	internal_t update(size_t idx,
										const T& value,
										size_t nodeIdx,
										size_t nodeLeft,
										size_t nodeRight) {
		if (idx < nodeLeft || nodeRight < idx) {
			return tree_[nodeIdx];
		}
		if (nodeLeft == nodeRight) {
			return tree_[nodeIdx] = transformFn_(value);
		}
		size_t mid = (nodeLeft + nodeRight) / 2;
		internal_t res_left = update(idx, value, nodeIdx * 2, nodeLeft, mid);
		internal_t res_right =
				update(idx, value, nodeIdx * 2 + 1, mid + 1, nodeRight);
		return tree_[nodeIdx] = aggregateFn_(res_left, res_right);
	}
};
endsnippet

snippet clsfenwicktree "Fenwick tree, binary indexed tree"
class FenwickTree {
 public:
	using T = long long;
	vector<T> arr_;
	vector<T> tree_;

 public:
	FenwickTree(size_t n) 
		: arr_(n, defaultValue()) 
		, tree_(n, defaultValue()) 
	{}

	FenwickTree(const vector<T>& arr) {
		init(arr);
	}

 public:
	void update(int i, const T& val) {
		T diff = val - arr_[i];
		arr_[i] = val;
		while (i < tree_.size()) {
			tree_[i] += diff;
			i += LSB(i);
		}
	}

	T query(int i) {
		T res = defaultValue();
		while (i > 0) {
			res += tree_[i];
			i -= LSB(i);
		}
		return res;
	}

	T query(int i, int j) {
		T res = defaultValue();
		for (i--; j > i; j -= LSB(j)) {
			res += tree_[j];
		}
		for (; i > j; i -= LSB(i)) {
			res -= tree_[i];
		}
		return res;
	}

	static inline T defaultValue() {
		return 0;
	}

	static inline int LSB(int i) { return i & (-i); }

 private:
	void init(const vector<T>& arr) {
		arr_ = arr;
		tree_ = arr;
		for (int i = 1; i < tree_.size(); ++i) {
			int j = i + LSB(i);
			if (j < tree_.size())
				tree_[j] += tree_[i];
		}
	}
};
endsnippet


snippet clscountingsegtree "Counting Segment tree"
template<typename T>
class CountingSegTree {
 public:
	vector<T> tree_;
	size_t n_;

	vector<int> count_;

 public:
	CountingSegTree(size_t size) {
		n_ = size;
		tree_.resize(4 * n_, 0);
		count_.resize(4 * n_, 0);
	}

	T query(size_t left, size_t right) {
		return query(left, right, 1, 0, n_ - 1);
	}

	void updateRange(size_t left, size_t right, int inc, 
			const function<T(int, size_t, size_t)>& transform) {
		updateRange(left, right, inc, 1, 0, n_ - 1, transform);
	}

 private:
	T query(size_t left,
					size_t right,
					size_t node_idx,
					size_t node_left,
					size_t node_right) {
		if (right < node_left || node_right < left) {
			return 0;
		}
		if (left <= node_left && node_right <= right) {
			return tree_[node_idx];
		}
		size_t mid = (node_left + node_right) / 2;
		T res_left = query(left, right, node_idx * 2, node_left, mid);
		T res_right = query(left, right, node_idx * 2 + 1, mid + 1, node_right);
		return aggregate(res_left, res_right);
	}

	void updateRange(
			size_t left, 
			size_t right,
			const int& inc,
			size_t node_idx,
			size_t node_left,
			size_t node_right, 
			const function<T(int, size_t, size_t)>& transform) {
		if (right < node_left || node_right < left) {
			return;
		}
		if (left <= node_left && node_right <= right) {
			count_[node_idx] += inc;
		}
		else {
			size_t mid = (node_left + node_right) / 2;
			updateRange(left, right, inc, node_idx * 2, node_left, mid, transform);
			updateRange(left, right, inc, node_idx * 2 + 1, mid+1, node_right, transform);
		}

		if (count_[node_idx]) {
			tree_[node_idx] = transform(0, node_left, node_right);
		}
		else if (node_left == node_right) {
			tree_[node_idx] = 0;
		}
		else {
			tree_[node_idx] = aggregate(tree_[node_idx * 2], tree_[node_idx * 2 + 1]);
		}
	}

	static T aggregate(const T& lhs, const T& rhs) { return lhs + rhs; }
};
endsnippet
